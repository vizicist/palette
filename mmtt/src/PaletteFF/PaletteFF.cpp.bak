#include <FFGL.h>
#include <FFGLLib.h>
#include <pthread.h>

#include <iostream>
#include <fstream>
#include <strstream>
#include <cstdlib> // for srand, rand
#include <ctime>   // for time

#include "NosuchDebug.h"
#include "NosuchUtil.h"
#include "NosuchOscInput.h"
#include "PaletteFF.h"
#include "Event.h"
#include "PaletteOscInput.h"
#include "NosuchScheduler.h"
#include "Palette.h"
#include "Param.h"
#include "Cursor.h"
#include "Region.h"
#include "Behaviour.h"
#include "Scale.h"
#include "Sound.h"
#include "Resolume.h"
#include "GraphicBehaviour.h"
#include "MusicBehaviour.h"
#include "Sprite.h"
#include "osc/OscOutboundPacketStream.h"

// #define FFPARAM_BRIGHTNESS (0)

////////////////////////////////////////////////////////////////////////////////////////////////////
//  Plugin information
////////////////////////////////////////////////////////////////////////////////////////////////////

static CFFGLPluginInfo PluginInfo ( 
	PaletteFF::CreateInstance,	// Create method
	"NSPL",								// Plugin unique ID
	"Palette",     // Plugin name											
	1,						   			// API major version number 													
	000,								  // API minor version number	
	1,										// Plugin major version number
	000,									// Plugin minor version number
	FF_EFFECT,						// Plugin type
	"Space Palette: TUIO-controlled graphics and music",	// Plugin description
	"by Tim Thompson - me@timthompson.com" // About
);

bool PaletteFF::StaticInitialized = false;

bool
palette_setdll(std::string dllpath)
{
	dllpath = NosuchTolower(dllpath);

	size_t lastslash = dllpath.find_last_of("/\\");
	size_t lastunder = dllpath.find_last_of("_");
	size_t lastdot = dllpath.find_last_of(".");
	std::string suffix = (lastdot==dllpath.npos?"":dllpath.substr(lastdot));

	if ( suffix != ".dll" ) {
		NosuchDebug("Hey! dll name (%s) isn't of the form *.dll!?",dllpath.c_str());
		return FALSE;
	}

	std::string dir = dllpath.substr(0,lastslash);
	std::string prefix = dllpath.substr(lastslash+1,lastdot-lastslash-1);

	NosuchPublicDir = dir;

	NosuchDebugSetLogDirFile(dir,"debug.txt");

	struct _stat statbuff;
	int e = _stat(NosuchPublicDir.c_str(),&statbuff);
	if ( ! (e == 0 && (statbuff.st_mode | _S_IFDIR) != 0) ) {
		NosuchDebug("Hey! No directory %s!?",NosuchPublicDir.c_str());
		return FALSE;
	}

	NosuchDebug("Setting NosuchPublicDir = %s",NosuchPublicDir.c_str());

	return TRUE;

}


void *network_threadfunc(void *arg)
{
	ManifoldDaemon* b = (ManifoldDaemon*)arg;
	return b->network_input_threadfunc(arg);
}

ManifoldDaemon::ManifoldDaemon(PaletteFF* mf, int osc_input_port, std::string osc_input_host, int http_input_port)
{
	NosuchDebug(2,"ManifoldDaemon CONSTRUCTOR!");

	_manifold = mf;
	_network_thread_created = false;
	daemon_shutting_down = false;

	NosuchDebug(2,"CREATING _oscinput and PaletteServer!!");
	_oscinput = new PaletteOscInput(osc_input_host.c_str(),osc_input_port);
	_oscinput->Listen();

	_http = new PaletteHttp(mf, http_input_port,60);

#if 0
	NosuchDebug(2,"ADDING OSC and JSON Processors in initStuff");
	_oscinput->AddOscProcessor(mf);
	_http->AddJsonProcessor(mf);
#endif

	NosuchDebug(2,"About to use pthread_create in ManifoldDaemon");
	int err = pthread_create(&_network_thread, NULL, network_threadfunc, this);
	if (err) {
		NosuchDebug("pthread_create failed!? err=%d\n",err);
		NosuchErrorOutput("pthread_create failed!?");
	} else {
		_network_thread_created = true;
		NosuchDebug("ManifoldDaemon is running");
	}
}

ManifoldDaemon::~ManifoldDaemon()
{
	NosuchDebug("ManifoldDaemon DESTRUCTOR starts!");
	daemon_shutting_down = true;
	if ( _network_thread_created ) {
		// pthread_detach(_network_thread);
		pthread_join(_network_thread,NULL);
	}

	NosuchAssert(_http != NULL);
	NosuchAssert(_oscinput != NULL);

	NosuchDebug("ManifoldDaemon destructor, removing processor from _http!");
	delete _http;
	_http = NULL;

	NosuchDebug("ManifoldDaemon destructor, removing processor from _oscinput!");
	_oscinput->RemoveOscProcessor(_manifold);
	_oscinput->UnListen();
	delete _oscinput;
	NosuchDebug("ManifoldDaemon destructor, after removing processor from _oscinput!");
	_oscinput = NULL;

	NosuchDebug("ManifoldDaemon DESTRUCTOR ends!");
}

void *ManifoldDaemon::network_input_threadfunc(void *arg)
{
	while (daemon_shutting_down == false ) {
		if ( _http ) {
			_http->Check();
		}
		if ( _oscinput ) {
			_oscinput->Check();
		}
	}
	return NULL;
}

int PaletteFF::NumEffectSet() {
	return NUM_EFFECT_SETS;
}

void PaletteFF::LoadEffectSet(int eset) {
	NosuchDebug(1,"PaletteFF::LoadEffectSet eset=%d",eset);
	if ( eset >= NumEffectSet() ) {
		NosuchDebug("Hey!  eset=%d is >= NumEffectSet?",eset);
		return;
	}
#ifdef RANDOM_EFFECT_7
	if ( eset == 7 ) {
		NosuchDebug("EFFECT SELECTION! ALL RANDOM!");
		LoadEffectSetRandom();
	} else
#endif
	{
		NosuchDebug("EFFECT SELECTION! set=%d",eset);
		EffectSet es = buttonEffectSet[eset];
		for ( int e=0; e<13; e++ ) {
			EnableEffect(e, es.effectOn[e]);
		}
	}
}

void PaletteFF::LoadEffectSetRandom() {
	NosuchDebug("PaletteFF::LoadEffectSetRandom");
	for ( int e=0; e<13; e++ ) {
		float r = (((float)rand())/RAND_MAX);
		// 25% of them will be on
		EnableEffect(e, r < 0.25 ? 1 : 0);
	}
}

void PaletteFF::StaticInitialization()
{
	srand( Pt_Time() );

	// Default debugging stuff
	NosuchDebugLevel = 0;   // 0=minimal messages, 1=more, 2=extreme
	NosuchDebugTimeTag = true;
	NosuchDebugThread = false;
	NosuchDebugToConsole = true;
	NosuchDebugToLog = true;
	NosuchAppName = "Manifold";
#ifdef DEBUG_TO_BUFFER
	NosuchDebugToBuffer = true;
#endif
	NosuchDebugAutoFlush = true;
	NosuchDebugLogFile = NosuchPublicPath("debug.txt");
	
	NosuchDebug(1,"=== Manifold Static Initialization!");
}

PaletteFF* RealManifold = NULL;

PaletteFF::PaletteFF() : CFreeFrameGLPlugin()
{
	NosuchDebug(1,"=== Manifold is being constructed.");

	_recompileFunc = NULL;
	_python_enabled = FALSE;
	_python_events_disabled = TRUE;
	_dotest = FALSE;
	_textEraseTime = 0;

	_resolumehost = "127.0.0.1";  // This should always be the case
	_resolume_output_port = DEFAULT_RESOLUME_PORT;

	_pyfflehost = "127.0.0.1";  // This should always be the case
	_pyffle_output_port = DEFAULT_PYFFLE_PORT;

	_osc_input_port = DEFAULT_OSC_INPUT_PORT;
	_osc_input_host = DEFAULT_OSC_INPUT_HOST;
	_http_input_port = DEFAULT_HTTP_INPUT_PORT;

	_scheduler = new NosuchScheduler();

	_looper = new NosuchLooper(this);
	_daemon = NULL;

	initialized = false;
	gl_shutting_down = false;

	width = 1.0f;
	height = 1.0f;

	// Don't do any OpenGL calls here, it isn't initialized yet.

	NosuchLockInit(&json_mutex,"json");
	json_cond = PTHREAD_COND_INITIALIZER;
	json_pending = false;

	NosuchLockInit(&palette_mutex,"palette");
	NosuchLockInit(&python_mutex,"python");

	// Input properties
#ifdef FFGL_SOURCE
	SetMinInputs(0);
	SetMaxInputs(0);
#else
	SetMinInputs(1);
	SetMaxInputs(1);
#endif

	m_filled = false;
	m_stroked = false;
	
	disabled = false;
	disable_on_exception = false;
}

PaletteFF::~PaletteFF()
{
	NosuchDebug(1,"Manifold destructor called");
	gl_shutting_down = true;
	scheduler()->Stop();
	delete _scheduler;
	_scheduler = NULL;

	if ( _daemon != NULL ) {
		delete _daemon;
		_daemon = NULL;
	}
	NosuchDebug(1,"Manifold destructor end");
}
////////////////////////////////////////////////////////////////////////////////////////////////////
//  Methods
////////////////////////////////////////////////////////////////////////////////////////////////////

void PaletteFF::rect(float x, float y, float w, float h) {
	// if ( w != 2.0f || h != 2.0f ) {
	// 	NosuchDebug("Drawing rect xy = %.3f %.3f  wh = %.3f %.3f",x,y,w,h);
	// }
	quad(x,y, x+w,y,  x+w,y+h,  x,y+h);
}
void PaletteFF::fill(NosuchColor c, float alpha) {
	m_filled = true;
	m_fill_color = c;
	m_fill_alpha = alpha;
}
void PaletteFF::stroke(NosuchColor c, float alpha) {
	// glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, alpha);
	m_stroked = true;
	m_stroke_color = c;
	m_stroke_alpha = alpha;
}
void PaletteFF::noStroke() {
	m_stroked = false;
}
void PaletteFF::noFill() {
	m_filled = false;
}
void PaletteFF::background(int b) {
	NosuchDebug("PaletteFF::background!");
}
void PaletteFF::strokeWeight(float w) {
	glLineWidth((GLfloat)w);
}
void PaletteFF::rotate(float degrees) {
	glRotatef(degrees,0.0f,0.0f,1.0f);
	// glRotatef(a,1.0f,0.0f,0.0f);
	// glRotatef(a,0.0f,1.0f,0.0f);
}
void PaletteFF::translate(float x, float y) {
	glTranslatef(x,y,0.0f);
}
void PaletteFF::scale(float x, float y) {
	glScalef(x,y,1.0f);
	// NosuchDebug("SCALE xy= %f %f",x,y);
}
void PaletteFF::quad(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3) {
	NosuchDebug(2,"   Drawing quad = %.3f %.3f, %.3f %.3f, %.3f %.3f, %.3f %.3f",x0,y0,x1,y1,x2,y2,x3,y3);
	if ( m_filled ) {
		glBegin(GL_QUADS);
		NosuchColor c = m_fill_color;
		glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, m_fill_alpha);
		glVertex2f( x0, y0); 
		glVertex2f( x1, y1); 
		glVertex2f( x2, y2); 
		glVertex2f( x3, y3); 
		glEnd();
	}
	if ( m_stroked ) {
		NosuchColor c = m_stroke_color;
		glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, m_stroke_alpha);
		glBegin(GL_LINE_LOOP); 
		glVertex2f( x0, y0); 
		glVertex2f( x1, y1); 
		glVertex2f( x2, y2); 
		glVertex2f( x3, y3); 
		glEnd();
	}
	if ( ! m_filled && ! m_stroked ) {
		NosuchDebug("Hey, quad() called when both m_filled and m_stroked are off!?");
	}
}
void PaletteFF::triangle(float x0, float y0, float x1, float y1, float x2, float y2) {
	NosuchDebug(2,"Drawing triangle xy0=%.3f,%.3f xy1=%.3f,%.3f xy2=%.3f,%.3f",x0,y0,x1,y1,x2,y2);
	if ( m_filled ) {
		NosuchColor c = m_fill_color;
		glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, m_fill_alpha);
		NosuchDebug(2,"   fill_color=%d %d %d alpha=%.3f",c.r(),c.g(),c.b(),m_fill_alpha);
		glBegin(GL_TRIANGLE_STRIP); 
		glVertex3f( x0, y0, 0.0f );
		glVertex3f( x1, y1, 0.0f );
		glVertex3f( x2, y2, 0.0f );
		glEnd();
	}
	if ( m_stroked ) {
		NosuchColor c = m_stroke_color;
		glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, m_stroke_alpha);
		NosuchDebug(2,"   stroke_color=%d %d %d alpha=%.3f",c.r(),c.g(),c.b(),m_stroke_alpha);
		glBegin(GL_LINE_LOOP); 
		glVertex2f( x0, y0); 
		glVertex2f( x1, y1);
		glVertex2f( x2, y2);
		glEnd();
	}
	if ( ! m_filled && ! m_stroked ) {
		NosuchDebug("Hey, triangle() called when both m_filled and m_stroked are off!?");
	}
}

void PaletteFF::line(float x0, float y0, float x1, float y1) {
	// NosuchDebug("Drawing line xy0=%.3f,%.3f xy1=%.3f,%.3f",x0,y0,x1,y1);
	if ( m_stroked ) {
		NosuchColor c = m_stroke_color;
		glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, m_stroke_alpha);
		// NosuchDebug(2,"   stroke_color=%d %d %d alpha=%.3f",c.r(),c.g(),c.b(),m_stroke_alpha);
		glBegin(GL_LINES); 
		glVertex2f( x0, y0); 
		glVertex2f( x1, y1);
		glEnd();
	} else {
		NosuchDebug("Hey, line() called when m_stroked is off!?");
	}
}

static float degree2radian(float deg) {
	return 2.0f * (float)M_PI * deg / 360.0f;
}

void PaletteFF::ellipse(float x0, float y0, float w, float h) {
	NosuchDebug(2,"Drawing ellipse xy0=%.3f,%.3f wh=%.3f,%.3f",x0,y0,w,h);
	if ( m_filled ) {
		NosuchColor c = m_fill_color;
		glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, m_fill_alpha);
		NosuchDebug(2,"   fill_color=%d %d %d alpha=%.3f",c.r(),c.g(),c.b(),m_fill_alpha);
		glBegin(GL_TRIANGLE_FAN);
		float radius = w;
		glVertex2f(x0, y0);
		for ( float degree=0.0f; degree <= 360.0f; degree+=5.0f ) {
			glVertex2f(x0 + sin(degree2radian(degree)) * radius, y0 + cos(degree2radian(degree)) * radius);
		}
		glEnd();
	}
	if ( m_stroked ) {
		NosuchColor c = m_stroke_color;
		glColor4f(c.r()/255.0f, c.g()/255.0f, c.b()/255.0f, m_stroke_alpha);
		NosuchDebug(2,"   stroke_color=%d %d %d alpha=%.3f",c.r(),c.g(),c.b(),m_stroke_alpha);
		glBegin(GL_LINE_LOOP);
		float radius = w;
		for ( float degree=0.0f; degree <= 360.0f; degree+=5.0f ) {
			glVertex2f(x0 + sin(degree2radian(degree)) * radius, y0 + cos(degree2radian(degree)) * radius);
		}
		glEnd();
	}

	if ( ! m_filled && ! m_stroked ) {
		NosuchDebug("Hey, ellipse() called when both m_filled and m_stroked are off!?");
	}
}

void PaletteFF::popMatrix() {
	glPopMatrix();
}

void PaletteFF::pushMatrix() {
	glPushMatrix();
}

static std::string patchfilename(std::string name) {
	return NosuchPublicPath("patches\\"+name);
}

static PyObject*
getpythonfunc(PyObject *module, const char *name, const char *modname)
{
	PyObject *f = PyObject_GetAttrString(module, name);
	if (!(f && PyCallable_Check(f))) {
		NosuchDebug("Unable to find python method %s in %s",name,modname);
		return NULL;
	}
	return f;
}

PyObject*
PaletteFF::python_lock_and_call(PyObject* func, PyObject *pArgs)
{
	lock_python();
	PyObject *msgValue = PyObject_CallObject(func, pArgs);
	unlock_python();
	return msgValue;
}

bool
PaletteFF::python_recompileModule(char *modulename)
{
	PyObject *pArgs;
	bool r = FALSE;

	if ( _recompileFunc == NULL ) {
		NosuchDebug("Hey, _recompileFunc is NULL!?");
		return FALSE;
	}

	pArgs = Py_BuildValue("(s)", modulename);
	if ( pArgs == NULL ) {
		NosuchDebug("Cannot create python arguments to recompile");
		goto getout;
	}            
	PyObject *msgValue = python_lock_and_call(_recompileFunc, pArgs);
	Py_DECREF(pArgs);
	if (msgValue == NULL) {
		NosuchDebug("Call to recompile of %s failed\n",modulename);
	} else if (msgValue == Py_None) {
		NosuchDebug("Call to recompile of %s returned None?\n",modulename);
	} else {
		char *msg = PyString_AsString(msgValue);
		r = (*msg != '\0') ? FALSE : TRUE;
		if ( r == FALSE ) {
			NosuchDebug("Call to recompile of %s failed, msg=%s\n",modulename,msg);
		}
		Py_DECREF(msgValue);
	}
getout:
	Py_XDECREF(_nosuchUtilModule);
	return r;
}

#define RANDONE (((float)rand())/RAND_MAX)
#define RANDB ((((float)rand())/RAND_MAX)*2.0f-1.0f)

void
PaletteFF::test_draw()
{
	for ( int i=0; i<1000; i++ ) {
		glColor4f(RANDONE,RANDONE,RANDONE,RANDONE);
		glBegin(GL_QUADS);
		glVertex2f(RANDB,RANDB);
		glVertex2f(RANDB,RANDB);
		glVertex2f(RANDB,RANDB);
		glVertex2f(RANDB,RANDB);
		glVertex2f(RANDB,RANDB);
		glEnd();
	}
}

#if 0
std::string
PaletteFF::python_process_osc()
{
	NosuchAssert(_callBoundFunc);

	PyObject *pArgs = Py_BuildValue("(O)",_processorOscFunc);
	if ( pArgs == NULL ) {
		return "Cannot create python arguments to _callBoundFunc";
	}            
	PyObject *msgobj = python_lock_and_call(_callBoundFunc, pArgs);
	Py_DECREF(pArgs);
	
	if (msgobj == NULL) {
		return "Call to _callBoundFunc failed";
	}
	if (msgobj == Py_None) {
		return "Call to _callBoundFunc returned None?";
	}
	std::string msg = std::string(PyString_AsString(msgobj));
	Py_DECREF(msgobj);
	if ( msg != "" ) {
		NosuchDebug("python_process_osc returned msg = %s",msg.c_str());
	}
	return msg;
}
#endif

std::string
PaletteFF::python_draw()
{
	NosuchAssert(_callBoundFunc);
	NosuchAssert(_processorDrawFunc);

	PyObject *pArgs = Py_BuildValue("(O)",_processorDrawFunc);
	if ( pArgs == NULL ) {
		return "Cannot create python arguments to _callBoundFunc";
	}            
	PyObject *msgobj = python_lock_and_call(_callBoundFunc, pArgs);
	Py_DECREF(pArgs);
	
	if (msgobj == NULL) {
		return "Call to _callBoundFunc failed";
	}
	if (msgobj == Py_None) {
		return "Call to _callBoundFunc returned None?";
	}
	std::string msg = std::string(PyString_AsString(msgobj));
	Py_DECREF(msgobj);
	if ( msg != "" ) {
		NosuchDebug("python_callbehaviour returned msg = %s",msg.c_str());
	}
	return msg;
}

PyObject*
PaletteFF::python_getProcessorObject(const char *btype)
{
	std::string dir = NosuchForwardSlash(NosuchPublicPath(""));
	PyObject *pArgs = Py_BuildValue("(ss)", btype,dir.c_str());
	if ( pArgs == NULL ) {
		NosuchDebug("Cannot create python arguments to _getProcessorFunc");
		return NULL;
	}            
	PyObject *obj = python_lock_and_call(_getProcessorFunc, pArgs);
	Py_DECREF(pArgs);
	if (obj == NULL) {
		NosuchDebug("Call to _getProcessorFunc failed");
		return NULL;
	}
	if (obj == Py_None) {
		NosuchDebug("Call to _getProcessorFunc returned None?");
		return NULL;
	}
	return obj;
}

#if 0
void
NSGalaxyD::deinstantiate()
{
	/* Do plugin-specific deinstantiation here */
	cvReleaseImage(&accum1);
	cvReleaseImage(&accum2);
	cvReleaseImage(&accum3);

	if ( pythonWorking ) {
		Py_XDECREF(_PyffleUtilModule);
		Py_XDECREF(getsurfaceFunc);
		Py_XDECREF(getcontextFunc);
		Py_XDECREF(getpcontextFunc);
		// Py_XDECREF(addparticleFunc);
		Py_XDECREF(advancetimeFunc);
		Py_XDECREF(gotoscFunc);
		Py_XDECREF(surface1Value);
		Py_XDECREF(surface2Value);
		Py_XDECREF(context1Value);
		Py_XDECREF(context2Value);
		Py_XDECREF(pcontextValue);
	}

	NSPlugin::deinstantiate();
}
#endif

static PyObject* nosuchmedia_debug(PyObject* self, PyObject* args)
{
    const char* name;
 
    if (!PyArg_ParseTuple(args, "s", &name))
        return NULL;
 
	NosuchDebug("(from python) %s",name);
 
    Py_RETURN_NONE;
}
 
static PyObject* nosuchmedia_glVertex2f(PyObject* self, PyObject* args)
{
	float v1, v2;

    if (!PyArg_ParseTuple(args, "ff", &v1, &v2))
        return NULL;
 
	// NosuchDebug("(from python) glVertex2f %f %f",v1,v2);
	glVertex2f( v1,v2);
 
    Py_RETURN_NONE;
}
 
static PyObject* nosuchmedia_cursors(PyObject* self, PyObject* args)
{
	float v1, v2;

    if (!PyArg_ParseTuple(args, "ff", &v1, &v2))
        return NULL;
 
    Py_RETURN_NONE;
}
 
static PyObject* nosuchmedia_next_event(PyObject* self, PyObject* args)
{
	PyEvent* ev = RealManifold->palette()->popPyEvent();
	if ( ev == NULL ) {
	    Py_RETURN_NONE;
	} else {
		PyObject* e = ev->python_object();
		delete ev;
		return e;
	}
}

static PyObject* nosuchmedia_region_define(PyObject* self, PyObject* args) {
	const char* region_name;
	const char* region_type;
	int sid_low;
	int sid_high;

	// NosuchDebug("(builtin) region_define");
    if (!PyArg_ParseTuple(args, "ssii", &region_name, &region_type, &sid_low, &sid_high))
        return NULL;

	Region* region;
	NosuchDebug(1,"region_define region=%s sid_low=%d sid_high=%d type=%s",region_name,sid_low,sid_high,region_type);
	if ( strcmp(region_type,"surface") == 0 ) {
		region = Palette::palette()->NewSurfaceNamed(region_name,sid_low,sid_high);
	} else if ( strcmp(region_type,"button") == 0 ) {
		region = Palette::palette()->NewButtonNamed(region_name,sid_low,sid_high);
	} else {
		NosuchDebug("Unrecognized region type in region_define: %s",region_type);
	}
    Py_RETURN_NONE;
}
 
static PyObject* nosuchmedia_region_change_sound(PyObject* self, PyObject* args) {
	const char* region_name;
	const char* sound_name;

	// NosuchDebug("(builtin) region_change_sound");
    if (!PyArg_ParseTuple(args, "ss", &region_name, &sound_name))
        return NULL;

	NosuchDebug(1,"region_change_sound region=%s sound=%s",region_name,sound_name);
	int ch = Palette::palette()->setRegionSound(region_name,sound_name);
    // Py_RETURN_NONE;
	return Py_BuildValue("i", ch);
}
 
static PyObject* nosuchmedia_note_on(PyObject* self, PyObject* args) {
	const char* sid;
	int ch;
	int milli;
	int pitch;

	// NosuchDebug("(builtin) note_on");
    if (!PyArg_ParseTuple(args, "siii", &sid, &ch, &milli, &pitch))
        return NULL;

	NosuchDebug(1,"builtin nosuchmedia_note_on start");
	Palette::palette()->schedNewNoteInMilliseconds(std::string(sid),ch,milli,pitch);
	NosuchDebug(1,"builtin nosuchmedia_note_on end");

    Py_RETURN_NONE;
}
 
static PyObject* nosuchmedia_session_end(PyObject* self, PyObject* args) {
	const char* sid;

	NosuchDebug(1,"(builtin) session_end");
    if (!PyArg_ParseTuple(args, "s", &sid))
        return NULL;

	Palette::palette()->schedSessionEnd(std::string(sid));

    Py_RETURN_NONE;
}
 
#ifdef OLD
static PyMethodDef PyffleMethods[] =
{
     {"debug", nosuchmedia_debug, METH_VARARGS, "Log debug output."},
     {"glVertex2f", nosuchmedia_glVertex2f, METH_VARARGS, "Invoke glVertext2f."},
     {"cursors", nosuchmedia_cursors, METH_VARARGS, "Get current cursors."},
     {"next_event", nosuchmedia_next_event, METH_VARARGS, "Get next event."},
     {NULL, NULL, 0, NULL}
};
#endif

static PyMethodDef ManifoldMethods[] =
{
     {"debug", nosuchmedia_debug, METH_VARARGS, "Log debug output."},
     {"glVertex2f", nosuchmedia_glVertex2f, METH_VARARGS, "Invoke glVertext2f."},
#if 0
     {"cursors", nosuchmedia_cursors, METH_VARARGS, "Get current cursors."},
#endif
     {"next_event", nosuchmedia_next_event, METH_VARARGS, "Get next event."},
     {"region_change_sound", nosuchmedia_region_change_sound, METH_VARARGS, "Change the sound of a region."},
     {"region_define", nosuchmedia_region_define, METH_VARARGS, "Specify a new region."},
     {"session_note_on", nosuchmedia_note_on, METH_VARARGS, "Generate MIDI note-on."},
     {"session_end", nosuchmedia_session_end, METH_VARARGS, "Generate MIDI note-offs."},
     {NULL, NULL, 0, NULL}
};
 
bool PaletteFF::python_init() {
	if ( ! Py_IsInitialized() ) {
		NosuchDebug("PaletteFF::initialize IS CALLING PY_INITIALIZE!");
		Py_Initialize();
	} else {
		NosuchDebug("PaletteFF::initialize is NOT calling PY_INITIALIZE, already running!");
	}

	(void) Py_InitModule("manifold.builtin", ManifoldMethods);

	// We want to add our directory to the sys.path
	std::string script = NosuchSnprintf(
		"import time\nimport sys\n"
		"sys.path.insert(0,'%s')\n",
			NosuchForwardSlash(NosuchPublicPath("python")).c_str()
		);
	PyRun_SimpleString(script.c_str());

	// PyObject *obj = PyString_FromString("nosuchutil");
    // _nosuchUtilModule = PyImport_Import(obj);
    // Py_DECREF(obj);

	const char *pyffleutil = "manifold.util";
	PyObject *pName = PyString_FromString(pyffleutil);
    _PyffleUtilModule = PyImport_Import(pName);
    Py_DECREF(pName);

	if ( _PyffleUtilModule == NULL) {
		python_disable("Unable to import pyffleutil module");
		return FALSE;
	}

	if (!(_recompileFunc = getpythonfunc(_PyffleUtilModule,"recompile",pyffleutil))) {
		python_disable("Can't get recompile function from manifold module?!");
		return FALSE;
	}

	if (!(_callBoundFunc=getpythonfunc(_PyffleUtilModule,"callboundfunc",pyffleutil))) {
		python_disable("Unable to find callboundfunc func");
		return FALSE;
	}

	if (!(_getProcessorFunc=getpythonfunc(_PyffleUtilModule,"getprocessor",pyffleutil))) {
		python_disable("Unable to find getprocessor func");
		return FALSE;
	}

#if 0
	NosuchDebug("Trying to recompile manifold.");
	if ( python_recompileModule("manifold") == FALSE ) {
		python_disable("Unable to recompile manifold module");
		return FALSE;
	}
	NosuchDebug("recompile manifold worked.");
#endif

	const char *processor = "Default";
	if ( !python_change_processor(processor) ) {
		std::string msg = NosuchSnprintf("Unable to change processor to %s",processor);
		python_disable(msg.c_str());
		return FALSE;
	}

	// python_draw();

	return TRUE;
}

bool
PaletteFF::python_change_processor(const char* behavename) {

	if ( !(_processorObj = python_getProcessorObject(behavename))) {
		NosuchDebug(ERROR_OUTPUT,"Can't get behavename=%s!",behavename);
		return FALSE;
	}
	if ( !(_processorDrawFunc = getpythonfunc(_processorObj, "processOpenGL", behavename)) ) {
		NosuchDebug(ERROR_OUTPUT,"Can't get processOpenGL from behavename=%s!",behavename);
		return FALSE;
	}
#if 0
	if ( !(_processorOscFunc = getpythonfunc(_processorObj, "processOSC", behavename)) ) {
		return FALSE;
	}
#endif
	return TRUE;
}

void PaletteFF::python_disable(std::string msg) {
	NosuchDebug(ERROR_OUTPUT,"python is being disabled!  msg=%s",msg.c_str());
	_python_enabled = FALSE;
}

bool PaletteFF::python_reloadPyffleUtilModule() {

	PyObject* newmod = PyImport_ReloadModule(_PyffleUtilModule);
	if ( newmod == NULL) {
		python_disable("Unable to reload manifold module");
		return FALSE;
	}
	_PyffleUtilModule = newmod;

	return TRUE;
}

int PaletteFF::python_runfile(std::string filename) {
	std::string fullpath = NosuchPublicPath("python") + "\\" + filename;
	std::ifstream f(fullpath.c_str(), std::ifstream::in);
	if ( ! f.is_open() ) {
		NosuchErrorOutput("Unable to open python file: %s",fullpath.c_str());
		return 1;
	}
	std::string contents;
	std::string line;
	while (!std::getline(f,line,'\n').eof()) {
		contents += (line+"\n");
	}
	f.close();
	int r = PyRun_SimpleString(contents.c_str());
	if ( r != 0 ) {
		NosuchErrorOutput("Error executing contents of: %s",fullpath.c_str());
	}
	return r;
}

static bool
istrue(std::string s)
{
	return(s == "true" || s == "True" || s == "1");
}

void PaletteFF::config_and_initialize() {
	std::string filename = patchfilename("default.mnf");
	NosuchDebug("Reading Manifold configuration from %s",filename.c_str());
	std::ifstream f(filename.c_str(), std::ifstream::in | std::ifstream::binary);
	if ( ! f.is_open() ) {
		NosuchDebug(ERROR_OUTPUT,"Unable to open config file: %s",filename.c_str());
	} else {
		read_config(f);
		f.close();
	}
	if ( _python_enabled ) {
		python_init();
	}
}

// Return everything after the '=' (and whitespace)
std::string
everything_after_char(std::string line, char lookfor = '=')
{
	const char *p = line.c_str();
	const char *q = strchr(p,lookfor);
	if ( q == NULL ) {
		NosuchDebug("Invalid format (no =): %s",p);
		return "";
	}
	q++;
	while ( *q != 0 && isspace(*q) ) {
		q++;
	}
	size_t len = strlen(q);
	if ( q[len-1] == '\r' ) {
		len--;
	}
	return std::string(q,len);
}

void PaletteFF::read_config(std::ifstream& f) {

	std::string line;
	std::string current_synth = "";
	int current_soundset = -1;
	std::string current_soundbank_name;
	int current_soundbank = -1;

	while (!std::getline(f,line,'\n').eof()) {
		std::vector<std::string> words = NosuchSplitOnAnyChar(line," \t\r=");
		if ( words.size() == 0 ) {
			continue;
		}
		std::string word0 = words[0];
		if ( word0[0] == '#' || word0 == "" ) {
			continue;
		}
		std::string word1 = (words.size()>1) ? words[1] : "";
		if ( word0 == "channel" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			int chan = atoi(word1.c_str());
			Synths[chan] = words[2];
		} else if ( word0 == "osc" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			std::string porthost = words[2];
			int port = atoi(porthost.c_str());
			std::string host = DEFAULT_OSC_INPUT_HOST;
			size_t atsign = porthost.find("@");
			if ( atsign != porthost.npos ) {
				host = porthost.substr(atsign+1);
			}
			if ( word1 == "input" ) {
				_osc_input_port = port;
				_osc_input_host = host;
			} else {
				NosuchDebug("Invalid format, expecting 'input': %s",line.c_str()); 
				continue;
			}
		} else if ( word0 == "resolume" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			int port = atoi(words[2].c_str());
			if ( word1 == "output" ) {
				_resolume_output_port = port;
			} else {
				NosuchDebug("Invalid format, expecting 'output': %s",line.c_str()); 
				continue;
			}
		} else if ( word0 == "http" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			int port = atoi(words[2].c_str());
			if ( word1 == "input" ) {
				_http_input_port = port;
			} else {
				NosuchDebug("Invalid format, expecting 'input': %s",line.c_str()); 
				continue;
			}
		} else if ( word0 == "include" ) {
			if ( words.size() < 2 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			// as a hack to eliminate the need for an '=' on the
			// include line, we take everything after the 'e'
			// (last character in "include").
			std::string basename = everything_after_char(line,'e');
			std::string filename = patchfilename(basename);
			std::ifstream incf(filename.c_str(), std::ifstream::in | std::ifstream::binary);
			if ( ! incf.is_open() ) {
				if ( basename.find_first_of("local") == 0 ) {
					// This is not necessarily an error
					NosuchDebug("Local include file not defined: %s",filename.c_str());
				} else {
					NosuchDebug(ERROR_OUTPUT,"Unable to open include file: %s",filename.c_str());
				}
			} else {
				read_config(incf);
				incf.close();
			}
		} else if ( word0 == "sid" ) {
			if ( words.size() < 4 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			int sidnum = atoi(word1.c_str());
			std::string sid = sidString(sidnum,"");
			std::string name = words[3];
			std::string word2 = words[2];
			Region* rgn;
			if ( word2 == "surface" ) {
				rgn = _palette->NewSurfaceNamed(name,sidnum,sidnum+32);
			} else if ( word2 == "button" ) {
				rgn = _palette->NewButtonNamed(name,sidnum,sidnum+32);
			} else {
				NosuchDebug("Invalid format (expecting surface or button): %s",line.c_str()); 
				continue;
			}
			NosuchDebug("New Region of type=%s, name=%s sidnum=%d rid=%d",word2.c_str(),name.c_str(),sidnum,rgn->id);
		} else if ( word0 == "debug" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			if ( word1 == "level" ) {
				NosuchDebugLevel = atoi(everything_after_char(line).c_str());
			} else if ( word1 == "tologfile" ) {
				NosuchDebugToLog = istrue(everything_after_char(line));
			} else if ( word1 == "toconsole" ) {
				NosuchDebugToConsole = istrue(everything_after_char(line));
			} else if ( word1 == "autoflush" ) {
				NosuchDebugAutoFlush = istrue(everything_after_char(line));
			}
		} else if ( word0 == "python" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			if ( word1 == "enabled" ) {
				_python_enabled = istrue(everything_after_char(line));
			} else if ( word1 == "path" ) {
				_python_path = everything_after_char(line).c_str();
			}
		} else if ( word0 == "midi" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			if ( word1 == "input" ) {
				_midi_input = everything_after_char(line);
			} else if ( word1 == "output" ) {
				_midi_output = everything_after_char(line);
				// std::string progname = everything_after_char(line);
			}
		} else if ( word0 == "synth" ) {
			if ( words.size() < 2 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			current_synth = word1;
		} else if ( word0 == "program" ) {
			if ( current_synth == "" ) {
				NosuchDebug("Invalid format (program seen before synth): %s",line.c_str()); 
				continue;
			}
			if ( words.size() < 2 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			int pnum = atoi(word1.c_str());
			std::string progname = everything_after_char(line);
			NosuchDebug(1,"Program %d = ((%s))",pnum,progname.c_str());
			Sounds[progname] = Sound(current_synth,pnum);
		} else if ( word0 == "soundbank" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			current_soundbank = atoi(word1.c_str());
			NosuchAssert(current_soundbank >=0 && current_soundbank < NUM_SOUNDBANKS);
			current_soundbank_name = words[2];
		} else if ( word0 == "soundset" ) {
			if ( words.size() < 2 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			current_soundset = atoi(word1.c_str());
			NosuchAssert(current_soundset >=0 && current_soundset < NUM_SOUNDSETS);
		} else if ( word0 == "sound" ) {
			if ( words.size() < 3 ) {
				NosuchDebug("Invalid format (too short): %s",line.c_str()); 
				continue;
			}
			int soundnum = atoi(word1.c_str());
			NosuchAssert(soundnum >=0 && soundnum < NUM_SOUNDS_IN_SET);
			std::string soundname = everything_after_char(line);
			SoundBank[current_soundbank][current_soundset][soundnum] = soundname;
		} else {
			NosuchDebug("Invalid format (unrecognized first word): %s",line.c_str()); 
			continue;
		}
	}
}

bool PaletteFF::initStuff() {

	NosuchDebug(1,"PaletteFF::initStuff starts");

	// test_stuff();

	bool r = true;
	try {
		// static initializations
		Scale::initialize();
		Cursor::initialize();
		GraphicBehaviour::initialize();
		MusicBehaviour::initialize();
		Sound::initialize();
		Sprite::initialize();
		Palette::initialize();
	
		_palette = new Palette(this);

		// Not static, config gets read here.
		config_and_initialize();

		_palette->init_loops();

		if ( _midi_output == "" ) {
			NosuchDebug("Warning: MIDI output wasn't defined in configuration!");
			_midi_output = "Midi Yoke:  1";
		}
		if ( _midi_input == "" ) {
			NosuchDebug("Warning: MIDI input wasn't defined in configuration!");
			_midi_input = "Midi Yoke:  2";
		}
		_scheduler->StartMidi(_midi_input,_midi_output);
		_scheduler->SetClickClient(_looper);
		_scheduler->SetSchedulerClient(this);

		_palette->initRegionSounds();

		_palette->now = Pt_Time();

		NosuchDebug(1,"CREATING new ManifoldDaemon!!");
		_daemon = new ManifoldDaemon(this,_osc_input_port,_osc_input_host,_http_input_port);

		_palette->ConfigLoad("default","graphic");
		_palette->ConfigLoad("default","music");

	} catch (NosuchException& e) {
		NosuchDebug("NosuchException: %s",e.message());
		r = false;
	} catch (...) {
		// Does this really work?  Not sure
		NosuchDebug("Some other kind of exception occured!?");
		r = false;
	}
	NosuchDebug(2,"PaletteFF::initStuff returns %s\n",r?"true":"false");
	return r;
}

void
PaletteFF::CursorDownNotification(Cursor* c) {
	Region* r = c->region();
	NosuchAssert(r);
	if ( ! r->Looping() ) {
		return;
	}
#if 0
	// XXX - UNFINISHED CURSOR MOTION LOOPING!
	NosuchDebug("Should be adding to loop cursor=%s",c->DebugString().c_str());
	NosuchCursorMotion* cm = new NosuchCursorMotion(0,c->pos(),c->depth());
	CursorLoopNotification(cm,r->loop());
#endif
}

void
PaletteFF::CursorLoopNotification(NosuchCursorMotion* cm, NosuchLoop* lp) {
	int clk = lp->click();
	SchedEvent* ev = new SchedEvent(cm,clk,lp->id());
	int nn = lp->AddLoopEvent(ev);
}

void
PaletteFF::OutputNotificationMidiMsg(MidiMsg* mm, std::string sid) {
	// NosuchDebug(1,"BEAMER OutputNotify midimsg=%s sid=%s",mm->DebugString().c_str(),sid.c_str());

	// The sid can be a TUIO session ID or a loop id
	if ( sid.at(0) == '-' ) {
		NosuchDebug(1,"OutputNotificationMidiMsg ignoring sid=%s",sid.c_str());
		return;
	}
#if 0
	std::string surf = SurfaceNameOfSid(sid);
	if ( surf == "" ) {
		NosuchDebug("Hey, unable to find surface for sid=%s in OutputNotificationMidiMsg",sid.c_str());
		return;
	}
#endif
	Region* r = _palette->RegionForSid(sid);
	if ( r == NULL ) {
		NosuchDebug(1,"OutputNotificationMidiMsg no region for sid=%s?",sid.c_str());
		return;
	}
	if ( r->type != Region::SURFACE ) {
		NosuchDebug(1,"OutputNotificationMidiMsg region for sid=%s surface?",sid.c_str());
		return;
	}
	NosuchAssert(r);

	if ( isSidCursor(sid) ) {
		// If the output is coming from a cursor, then we see if looping is on

		NosuchDebug(2,"Manifold OutputNotificationMidiMsg for Cursor, sid=%s",sid.c_str());
		r->OutputNotificationMidiMsg(mm,sid);

		if ( r->Looping() ) {
			NosuchLoop* lp = r->loop();
			int clk = lp->click();
			// NosuchDebug(1,"OutputNotificationMidiMsg should be looping this!  mm=%s sid=%s",mm->DebugString().c_str(),sid.c_str());
			MidiMsg* newmm = mm->clone();
			if ( newmm ) {
				SchedEvent* ev = new SchedEvent(newmm,clk,lp->id());
				NosuchDebug(2,"Creating new SchedEvent = %d",ev);
				int nn = lp->AddLoopEvent(ev);
				int maxnotes = r->loopnotesValue();
				NosuchDebug(1,"Added LoopEvent lp=%d nnotes=%d maxnotes=%d ev=%s",
					lp->id(),nn,maxnotes,ev->DebugString().c_str());
				if ( nn > maxnotes ) {
					NosuchDebug(1,"Removing note, maxnotes=%d nnotes=%d",maxnotes,nn);
					r->loop()->removeOldestNoteOn();
				}
			}
			// NosuchDebug("  After AddLoopEvent, lp = %s",lp->DebugString().c_str());
		}
	} else {
		// It's a MidiMsg from Looper output
		// NosuchDebug(2,"Manifold OutputNotificationMidiMsg for Loop, sid=%s mm=%s",sid.c_str(),mm->DebugString().c_str());
		r->OutputNotificationMidiMsg(mm,sid);
	}
}

DWORD PaletteFF::ProcessOpenGL(ProcessOpenGLStruct *pGL)
{
	if ( gl_shutting_down ) {
		return FF_SUCCESS;
	}
	if ( disabled ) {
		return FF_SUCCESS;
	}

	if ( ! initialized ) {
		NosuchDebug("Manifold calling initStuff()");
		if ( ! initStuff() ) {
			NosuchDebug("PaletteFF::initStuff failed, disabling plugin!");
			disabled = true;
			return FF_FAIL;
		}
		initialized = true;
		RealManifold = this;
	}

#ifdef FRAMELOOPINGTEST
	static int framenum = 0;
	static bool framelooping = FALSE;
#endif

	// NosuchDebug("ProcessOpenGL");
	CheckText(Palette::now);

	NosuchLock(&json_mutex,"json");
	if (json_pending) {
		// Execute json stuff and generate response
		NosuchDebug(2,"####### EXECUTING json method=%s now=%d",json_method.c_str(),Palette::now);
		json_result = ExecuteJson(json_method, json_params, json_id);
		json_pending = false;
		NosuchDebug(2,"####### Signaling json_cond! now=%d",Palette::now);
		int e = pthread_cond_signal(&json_cond);
		if ( e ) {
			NosuchDebug("ERROR from pthread_cond_signal e=%d\n",e);
		}
	}
	NosuchUnlock(&json_mutex,"json");

	bool passthru = TRUE;
	if ( passthru ) {
		if (pGL->numInputTextures<1)
			return FF_FAIL;

		if (pGL->inputTextures[0]==NULL)
			return FF_FAIL;
  
		FFGLTextureStruct &Texture = *(pGL->inputTextures[0]);

		//bind the texture handle
		glBindTexture(GL_TEXTURE_2D, Texture.Handle);
	}

#if 0
	// Draw line just to show we're alive
	glColor4f(0.0, 0.0, 1.0, 1.0);
	glBegin(GL_LINES); 
	glVertex2f( -0.5, -0.5); 
	glVertex2f( 0.5, 0.5); 
	glEnd(); 
#endif

	lock_palette();

	bool gotexception = false;
	try {
		CATCH_NULL_POINTERS;

		int tm = _palette->now;
		int begintm = _palette->now;
		int endtm = Pt_Time();
		NosuchDebug(2,"ProcessOpenGL tm=%d endtm=%d dt=%d",tm,endtm,(endtm-tm));

		if ( _python_enabled ) {
			python_draw();
		}

		glDisable(GL_TEXTURE_2D); 
		glEnable(GL_BLEND); 
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
		glLineWidth((GLfloat)3.0f);

		int ndt = 1;
		int n;
		for ( n=1; n<=ndt; n++ ) {
			tm = (int)(begintm + 0.5 + n * ((float)(endtm-begintm)/(float)ndt));
			if ( tm > endtm ) {
				tm = endtm;
			}
			int r = _palette->draw();

			if ( _dotest ) {
				test_draw();
			}
			_palette->advanceTo(tm);
			if ( r > 0 ) {
				NosuchDebug("Palette::draw returned failure? (r=%d)\n",r);
				gotexception = true;
				break;
			}
		}
	} catch (NosuchException& e ) {
		NosuchDebug("NosuchException in Palette::draw : %s",e.message());
		gotexception = true;
	} catch (...) {
		NosuchDebug("UNKNOWN Exception in Palette::draw!");
		gotexception = true;
	}

	if ( gotexception && disable_on_exception ) {
		NosuchDebug("DISABLING Manifold due to exception!!!!!");
		disabled = true;
	}

	unlock_palette();

	glDisable(GL_BLEND); 
	glEnable(GL_TEXTURE_2D); 
	// END NEW CODE

#ifdef FRAMELOOPINGTEST
	int w = Texture.Width;
	int h = Texture.Height;
#define NFRAMES 300
	static GLubyte* pixelArray[NFRAMES];
	if ( framelooping ) {
		glRasterPos2i(-1,-1);
		glDrawPixels(w,h,GL_RGB,GL_UNSIGNED_BYTE,pixelArray[framenum]);
		framenum = (framenum+1)%NFRAMES;
	} else {
		if ( framenum < NFRAMES ) {
			pixelArray[framenum] = new GLubyte[w*h*3];
			glReadPixels(0,0,w,h,GL_RGB,GL_UNSIGNED_BYTE,pixelArray[framenum]);
			framenum++;
		} else {
			framelooping = TRUE;
			framenum = 0;
		}
	}
#endif

	//disable texturemapping
	glDisable(GL_TEXTURE_2D);
	
	//restore default color
	glColor4f(1.f,1.f,1.f,1.f);
	
	return FF_SUCCESS;
}

void PaletteFF::lock_palette() {
	NosuchLock(&palette_mutex,"palette");
}

void PaletteFF::unlock_palette() {
	NosuchUnlock(&palette_mutex,"palette");
}

void PaletteFF::lock_python() {
	NosuchLock(&python_mutex,"python");
}

void PaletteFF::unlock_python() {
	NosuchUnlock(&python_mutex,"python");
}

DWORD PaletteFF::GetParameter(DWORD dwIndex)
{

	return FF_FAIL;  // no parameters

#if 0
	DWORD dwRet;
	switch (dwIndex) {

	case FFPARAM_BRIGHTNESS:
#pragma warning(disable:4311)
#pragma warning(disable:4312)
    //sizeof(DWORD) must == sizeof(float)
    *((float *)(unsigned)(&dwRet)) = m_brightness;
#pragma warning(default:4311)
#pragma warning(default:4312)
		return dwRet;

	default:
		return FF_FAIL;
	}
#endif
}

DWORD PaletteFF::SetParameter(const SetParameterStruct* pParam)
{
	if (pParam != NULL) {
		
		return FF_FAIL;  // no parameters

#if 0
		switch (pParam->ParameterNumber) {

		case FFPARAM_BRIGHTNESS:
      //sizeof(DWORD) must == sizeof(float)
#pragma warning(disable:4311)
#pragma warning(disable:4312)
      m_brightness = *((float *)(unsigned)&(pParam->NewParameterValue));
#pragma warning(default:4311)
#pragma warning(default:4312)
			break;

		default:
			return FF_FAIL;
		}

		return FF_SUCCESS;
#endif
	
	}

	return FF_FAIL;
}

bool has_invalid_char(const char *nm)
{
	for ( const char *p=nm; *p!='\0'; p++ ) {
		if ( ! isalnum(*p) )
			return true;
	}
	return false;
}

std::string PaletteFF::jsonFloatResult(float r, const char *id) {
	return NosuchSnprintf("{ \"jsonrpc\": \"2.0\", \"result\": %f, \"id\": \"%s\" }",r,id);
}

std::string PaletteFF::jsonIntResult(int r, const char *id) {
	return NosuchSnprintf("{ \"jsonrpc\": \"2.0\", \"result\": %d, \"id\": \"%s\" }\r\n",r,id);
}

std::string PaletteFF::jsonStringResult(std::string r, const char *id) {
	return NosuchSnprintf("{ \"jsonrpc\": \"2.0\", \"result\": \"%s\", \"id\": \"%s\" }\r\n",r.c_str(),id);
}

std::string PaletteFF::jsonMethError(std::string e, const char *id) {
	return jsonError(-32602, e,id);
}

std::string PaletteFF::jsonError(int code, std::string e, const char* id) {
	return NosuchSnprintf("{ \"jsonrpc\": \"2.0\", \"error\": {\"code\": %d, \"message\": \"%s\" }, \"id\":\"%s\" }\r\n",code,e.c_str(),id);
}

std::string PaletteFF::jsonConfigResult(std::string name, const char *id) {

	std::string suff = name.substr(name.length()-Palette::configSuffix.length());
	if (suff == Palette::configSuffix) {
		name = name.substr(0,name.length()-Palette::configSuffix.length());
	}
	return jsonStringResult(name,id);
}

std::string needString(std::string meth,cJSON *params,std::string nm) {

		cJSON *c = cJSON_GetObjectItem(params,nm.c_str());
		if ( ! c ) {
			throw NosuchException("Missing %s argument on %s method",nm.c_str(),meth.c_str());
		}
		if ( c->type != cJSON_String ) {
			throw NosuchException("Unexpected type for %s argument to %s method, expecting string",nm.c_str(),meth.c_str());
		}
		return c->valuestring;
}

int needInt(std::string meth,cJSON *params,std::string nm) {
		cJSON *c = cJSON_GetObjectItem(params,nm.c_str());
		if ( ! c ) {
			throw NosuchException("Missing %s argument on %s method",nm.c_str(),meth.c_str());
		}
		if ( c->type != cJSON_Number ) {
			throw NosuchException("Unexpected type for %s argument to %s method, expecting number",nm.c_str(),meth.c_str());
		}
		return c->valueint;
}

float needFloat(std::string meth,cJSON *params,std::string nm) {
		cJSON *c = cJSON_GetObjectItem(params,nm.c_str());
		if ( ! c ) {
			throw NosuchException("Missing %s argument on %s method",nm.c_str(),meth.c_str());
		}
		if ( c->type != cJSON_Number ) {
			throw NosuchException("Unexpected type for %s argument to %s method, expecting float",nm.c_str(),meth.c_str());
		}
		return (float)(c->valuedouble);
}

void needParams(std::string meth, cJSON* params) {
	if(params==NULL) {
		throw NosuchException("No parameters on %s method?",meth.c_str());
	}
}

int
PaletteFF::EnableEffect(int effectnum, bool enabled)
{
    char buffer[1024];
    osc::OutboundPacketStream p( buffer, sizeof(buffer) );
	// The effectnum internally is 0-12 (or whatever the number of effects is)
	// but Resolume knows them as effect 2-14 (effect 1 is Manifold)
	effectnum += 2;
	std::string addr = NosuchSnprintf("/activeclip/video/effect%d/bypassed",effectnum);
	int bypassed = enabled ? 0 : 1;
    p << osc::BeginMessage( addr.c_str() ) << bypassed << osc::EndMessage;
    return SendToResolume(p);
}

int PaletteFF::SendToResolume(osc::OutboundPacketStream& p) {
	NosuchDebug(1,"SendToResolume host=%s port=%d",_resolumehost,_resolume_output_port);
    return SendToUDPServer(_resolumehost,_resolume_output_port,p.Data(),(int)p.Size());
}

void
PaletteFF::ShowText(std::string text, int x, int y, int timeout) {
    char buffer[1024];
    osc::OutboundPacketStream p( buffer, sizeof(buffer) );
    p << osc::BeginMessage( "/set_text" ) << text.c_str() << osc::EndMessage;
    SendToUDPServer(_pyfflehost,_pyffle_output_port,p.Data(),(int)p.Size());
    p.Clear();
    p << osc::BeginMessage( "/set_pos" ) << x << y << osc::EndMessage;
    SendToUDPServer(_pyfflehost,_pyffle_output_port,p.Data(),(int)p.Size());
	if ( timeout > 0 ) {
		_textEraseTime = Pt_Time() + timeout;
	}
}

void
PaletteFF::CheckText(int millinow) {
	if ( _textEraseTime > 0 && millinow > _textEraseTime ) {
		NosuchDebug("Erasing Text!");
		_textEraseTime = 0;
		ShowText("",0,0,0);
	}
}

std::string PaletteFF::ExecuteJsonAndCatchExceptions(std::string meth, cJSON *params, const char *id) {
	std::string r;
	try {
		CATCH_NULL_POINTERS;

		r = ExecuteJson(meth,params,id);
	} catch (NosuchException& e) {
		std::string s = NosuchSnprintf("NosuchException in ProcessJson!! - %s",e.message());
		r = error_json(-32000,s.c_str(),id);
	} catch (...) {
		// This doesn't seem to work - it doesn't seem to catch other exceptions...
		std::string s = NosuchSnprintf("Some other kind of exception occured in ProcessJson!?");
		r = error_json(-32000,s.c_str(),id);
	}
	return r;
}

std::string PaletteFF::ExecuteJson(std::string meth, cJSON *params, const char *id) {

	static std::string errstr;  // So errstr.c_str() stays around, but I'm not sure that's now needed

	if ( meth == "debug_tail" ) {
#if 0
		cJSON *c_amount = cJSON_GetObjectItem(params,"amount");
		if ( ! c_amount ) {
			return error_json(-32000,"Missing amount argument",id);
		}
		if ( c_amount->type != cJSON_String ) {
			return error_json(-32000,"Expecting string type in amount argument to get",id);
		}
#endif
#ifdef DEBUG_DUMP_BUFFER
		std::string s = NosuchDebugDumpBuffer();
		std::string s2 = NosuchEscapeHtml(s);
		std::string result = 
			"{\"jsonrpc\": \"2.0\", \"result\": \""
			+ s2
			+ "\", \"id\": \""
			+ id
			+ "\"}";
		return(result);
#else
		return error_json(-32000,"DEBUG_DUMP_BUFFER not defined",id);
#endif
	}
	if ( meth == "_echo" || meth == "echo" ) {
		cJSON *c_value = cJSON_GetObjectItem(params,"value");
		if ( ! c_value ) {
			return error_json(-32000,"Missing value argument",id);
		}
		if ( c_value->type != cJSON_String ) {
			return error_json(-32000,"Expecting string type in value argument to echo",id);
		}
		return jsonStringResult(c_value->valuestring,id);
	}
	if (meth == "looping_on") {
		_palette->SetAllLooping(true,DEFAULT_LOOPFADE);
		return jsonIntResult(0,id);
	}
	if (meth == "looping_off") {
		_palette->SetAllLooping(false,-1);
		return jsonIntResult(0,id);
	}
	if (meth == "ANO") {
		_scheduler->ANO();
		return jsonIntResult(0,id);
	}
	if (meth == "clear_all") {
		palette()->SetAllLooping(false,DEFAULT_LOOPFADE);
		palette()->ClearAllLoops(true);
		scheduler()->ANO();
		return jsonIntResult(0,id);
	}
	if (meth == "range_full") {
		palette()->SetAllFullRange(true);
		return jsonIntResult(0,id);
	}
	if (meth == "range_normal") {
		palette()->SetAllFullRange(false);
		return jsonIntResult(0,id);
	}
	if (meth == "quantize_on") {
		Param* ps = palette()->getGlobalParam("doquantize");
		ps->setFloatValue(1.0);
		NosuchDebug("doquantize is set to 1.0");
		return jsonIntResult(0,id);
	}
	if (meth == "quantize_off") {
		Param* ps = palette()->getGlobalParam("doquantize");
		ps->setFloatValue(0.0);
		NosuchDebug("doquantize is set to 0.0");
		return jsonIntResult(0,id);
	}
	if (meth == "minmove_zero") {
		Param* ps = palette()->getGlobalParam("minmove");
		ps->setFloatValue(0.0f);
		NosuchDebug("minmove is set to 0.0");
		return jsonIntResult(0,id);
	}
	if (meth == "minmove_default") {
		Param* ps = palette()->getGlobalParam("minmove");
		ps->setFloatValue(0.05f);
		NosuchDebug("minmove is set to 0.05");
		return jsonIntResult(0,id);
	}
	if (meth == "tempo_slow") {
		NosuchScheduler::SetTempoFactor(2.0);
		return jsonIntResult(0,id);
	}
	if (meth == "tempo_fast") {
		NosuchScheduler::SetTempoFactor(1.0);
		return jsonIntResult(0,id);
	}
	if (meth == "tonic_change") {
		MusicBehaviour::tonic_change(_palette);
		return jsonIntResult(0,id);
	}
	if (meth == "tonic_reset") {
		MusicBehaviour::tonic_reset(_palette);
		return jsonIntResult(0,id);
	}
	if (meth == "randvisual") {
		int eset = rand() % NumEffectSet();
		LoadEffectSet(eset);
		return jsonIntResult(0,id);
	}
	if (meth == "randgraphic") {
		std::string name = _palette->ConfigLoadRand("graphic");
		return jsonIntResult(0,id);
	}
	if (meth == "config_load") {
		std::string name = needString(meth,params,"name");
		std::string paramtype = needString(meth,params,"paramtype");
		int r = needInt(meth,params,"region");
		if ( r != -1 ) {
			throw NosuchException("Can't handle config for for non-global region (%d)",r);
		}
		_palette->ConfigLoad(name,paramtype);
		return jsonConfigResult(name,id);
	}
	if (meth == "config_next" || meth == "config_prev") {
		std::string name = needString(meth,params,"name");
		std::string paramtype = needString(meth,params,"paramtype");
		int r = needInt(meth,params,"region");
		if ( r != -1 ) {
			throw NosuchException("Can't handle config for for non-global region (%d)",r);
		}
		int dir = ((meth == "config_next") ? 1 : -1);
		std::string cn = _palette->ConfigNext(name,paramtype,dir);
		_palette->ConfigLoad(cn,paramtype);
		return jsonConfigResult(cn,id);
	}
	if (meth == "config_rand") {
		int r = needInt(meth,params,"region");
		std::string paramtype = needString(meth,params,"paramtype");
		if ( r != -1 ) {
			throw NosuchException("Can't handle config for for non-global region (%d)",r);
		}
		std::string name = _palette->ConfigLoadRand(paramtype);
		return jsonConfigResult(name,id);
	}
	if (meth == "config_overwrite" || meth == "config_savenew")  {
		std::string name = needString(meth,params,"name");
		std::string paramtype = needString(meth,params,"paramtype");
		int r = needInt(meth,params,"region");
		if ( r != -1 ) {
			throw NosuchException("Can't handle config for for non-global region (%d)",r);
		}
		if ( meth == "config_savenew" ) {
			name = _palette->ConfigNew(name,paramtype);
			NosuchDebug("CONFIGNEW returned name=%s",name.c_str());
		}
		NosuchDebug("Config is saving name=%s",name.c_str());
		_palette->ConfigSave(name,paramtype);
		return jsonConfigResult(name,id);
	}
	if (meth == "set") {
		needParams(meth,params);
		std::string name = needString(meth,params,"name");
		std::string val = needString(meth,params,"value");
		int r = needInt(meth,params,"region");

		NosuchDebug("SET name=%s val=%s region=%d",name.c_str(),val.c_str(),r);
		
		// This will create an region-specific Param if it doesn't already exist
		// This also applies to globalParams (r == REGIONID_FOR_GLOBAL_PARAMS)
		// and globalRegionOverrideParams (r==REGIONID_FOR_OVERRIDE_PARAMS)
		boolean make_unset = false;
		if ( val == Param::UNSET_STRING ) {
			if ( r != REGIONID_FOR_OVERRIDE_PARAMS ) {
				throw NosuchException("Unexpected UNSET value when region != 2");
			}
			make_unset = true;
		}
		Param* p = _palette->getParam(name,r,true);
		if ( p != NULL ) {
			if ( p->type() == Param::FLOAT ) {
				if ( make_unset ) {
					Palette::globalRegionOverrideParams->remove(p);
					_palette->reInitParams();
					return jsonFloatResult(Param::UNSET_FLOAT,id);
				} else {
					float f = (float) atof(val.c_str());
					// XXX should there be a setFloatValue here!?
					_palette->reInitParams();
					return jsonFloatResult(f,id);
				}
			} else if ( p->type() == Param::STRING ) {
				if ( make_unset ) {
					Palette::globalRegionOverrideParams->remove(p);
					_palette->reInitParams();
					return jsonStringResult(Param::UNSET_STRING,id);
				} else {
					val = p->setStringValue(val);
					_palette->reInitParams();
					return jsonStringResult(val,id);
				}
			} else if ( p->type() == Param::VECTOR ) {
				throw NosuchException("get method can't handle vector parameter");
			} else {
				throw NosuchException("get method can't handle unknown type");
			}
		}
		throw NosuchException("get method can't handle unknown parameter: %s",name.c_str());
	}
	if (meth == "increment" || meth == "decrement" ) {
		needParams(meth,params);
		std::string name = needString(meth,params,"name");
		float amount = needFloat(meth,params,"amount");
		int r = needInt(meth,params,"region");
		
		// println(meth+" name=" + name + " amount=" + amount + " region="+r);
		
		Param* p = _palette->getRegionParam(name,r,true);
		int direction = (meth == "decrement") ? -1 : 1;
		if ( p != NULL ) {
			if ( p->type() == Param::FLOAT ) {
				// float f = (float) atof(amount.c_str());
				float v = p->floatValue();
				float range = p->floatMaxValue() - p->floatMinValue();
				v += direction * amount * range;
				NosuchDebug("SETFLOATVALUE of Param name=%s p=%d v=%f",name.c_str(),p,v);
				v = p->setFloatValue(v);
				_palette->reInitParams();
				if ( name == "soundset" ) {
					_palette->changeSoundSet((int)v);
				}
				return jsonFloatResult(v,id);
			} else if ( p->type() == Param::STRING ) {
				std::string ns;
				if ( name == "sound" ) {
					NosuchDebug("INC/DEC of sound, existing val=%s",p->stringValue().c_str());
					ns = Sound::nextSoundValue(direction,p->stringValue());
					p->setStringValue(ns);
					NosuchDebug("    new sound val=%s",ns.c_str());
					_palette->UpdateSound(r);
				} else {
					ns = p->nextStringValue(direction);
					p->setStringValue(ns);
				}
				_palette->reInitParams();
				return jsonStringResult(ns,id);
			} else {
				throw NosuchException("method=%s can't handle non-FLOAT type: %d\n",meth.c_str(),p->type());
			}
		}
		throw NosuchException("get method can't handle unknown parameter: %s\n",name.c_str());
	}
	if (meth == "toggle" ) {
		needParams(meth,params);
		std::string name = needString(meth,params,"name");
		int r = needInt(meth,params,"region");
		
		// HACK to allow testing of exception handling
		char *pp = NULL;
		if ( name == "changeable" && Pt_Time() > 0 ) {
			*pp = 0;
		}

		// This will create an region-specific Param if it doesn't already exist
		Param* p = _palette->getRegionParam(name,r,true);
		if ( p != NULL ) {
			if ( p->type() == Param::FLOAT ) {
				float v = p->floatValue();
				if ( v != 0.0 ) {
					v = 0.0f;
				} else {
					v = 1.0f;
				}
				v = p->setFloatValue(v);
				_palette->reInitParams();
				NosuchDebug("SETTING AREA-SPECIFIC PARAM FOR name=%s region=%d val=%f",name.c_str(),r,v);
				return jsonFloatResult(v,id);
			} else {
				throw NosuchException("method=%s can't handle non-FLOAT type=%d\n",meth.c_str(),p->type());
			}
		}
		throw NosuchException("get method can't handle unknown parameter: %s\n",name.c_str());
	}
	if (meth == "get") {
		needParams(meth,params);
		std::string name = needString(meth,params,"name");
		int r = needInt(meth,params,"region");
		
		NosuchDebug(2,"get method call!  name=%s region=%d",name.c_str(),r);
		Param* p = _palette->getRegionParam(name,r,false);
		if ( p != NULL ) {
			if ( p->type() == Param::FLOAT ) {
				return jsonFloatResult(p->floatValue(),id);
			} else if ( p->type() == Param::STRING ) {
				return jsonStringResult(p->stringValue(),id);
			} else if ( p->type() == Param::VECTOR ) {
				throw NosuchException("get method can't handle vector parameter: %s",name.c_str());
			} else {
				throw NosuchException("get method can't handle unknown type: %d"+p->type());
			}
		}
		throw NosuchException("get method can't handle unknown parameter: %s",name.c_str());
	}

	errstr = NosuchSnprintf("Unrecognized method name - %s",meth.c_str());
	return error_json(-32000,errstr.c_str(),id);
}

bool
PaletteFF::checkAddrPattern(const char *addr, char *patt)
{
	return ( strncmp(addr,patt,strlen(patt)) == 0 );
}

int
ArgAsInt32(const osc::ReceivedMessage& m, unsigned int n)
{
    osc::ReceivedMessage::const_iterator arg = m.ArgumentsBegin();
	const char *types = m.TypeTags();
	if ( n >= strlen(types) )  {
		DebugOscMessage("ArgAsInt32 ",m);
		throw NosuchException("Attempt to get argument n=%d, but not that many arguments on addr=%s\n",n,m.AddressPattern());
	}
	if ( types[n] != 'i' ) {
		DebugOscMessage("ArgAsInt32 ",m);
		throw NosuchException("Expected argument n=%d to be an int(i), but it is (%c)\n",n,types[n]);
	}
	for ( unsigned i=0; i<n; i++ )
		arg++;
    return arg->AsInt32();
}

float
ArgAsFloat(const osc::ReceivedMessage& m, unsigned int n)
{
    osc::ReceivedMessage::const_iterator arg = m.ArgumentsBegin();
	const char *types = m.TypeTags();
	if ( n >= strlen(types) )  {
		DebugOscMessage("ArgAsFloat ",m);
		throw NosuchException("Attempt to get argument n=%d, but not that many arguments on addr=%s\n",n,m.AddressPattern());
	}
	if ( types[n] != 'f' ) {
		DebugOscMessage("ArgAsFloat ",m);
		throw NosuchException("Expected argument n=%d to be a float(f), but it is (%c)\n",n,types[n]);
	}
	for ( unsigned i=0; i<n; i++ )
		arg++;
    return arg->AsFloat();
}

std::string
ArgAsString(const osc::ReceivedMessage& m, unsigned n)
{
    osc::ReceivedMessage::const_iterator arg = m.ArgumentsBegin();
	const char *types = m.TypeTags();
	if ( n < 0 || n >= strlen(types) )  {
		DebugOscMessage("ArgAsString ",m);
		throw NosuchException("Attempt to get argument n=%d, but not that many arguments on addr=%s\n",n,m.AddressPattern());
	}
	if ( types[n] != 's' ) {
		DebugOscMessage("ArgAsString ",m);
		throw NosuchException("Expected argument n=%d to be a string(s), but it is (%c)\n",n,types[n]);
	}
	for ( unsigned i=0; i<n; i++ )
		arg++;
	return std::string(arg->AsString());
}

static void
xy_adjust(float expand, float& x, float& y) {
	// The values we get from the Palette don't go all the way to
	// 0.0 or 1.0, so we expand
	// the range a bit so people can draw all the way to the edges.
	x = ((x - 0.5f) * expand) + 0.5f;
	y = ((y - 0.5f) * expand) + 0.5f;
	if (x < 0.0)
		x = 0.0f;
	else if (x > 1.0)
		x = 1.0f;
	if (y < 0.0)
		y = 0.0f;
	else if (y > 1.0)
		y = 1.0f;
}

std::string
sidString(int sidnum, const char* source)
{
	if ( strcmp(source,"") == 0 ) {
		return NosuchSnprintf("%d",sidnum);
	} else {
		return NosuchSnprintf("%d/%s",sidnum,source);  // The source has an @ in it already
	}
}

void PaletteFF::ProcessOscMessage( const char *source, const osc::ReceivedMessage& m) {
	static int Nprocessed = 0;
	Palette* thispalette = _palette; 
	try{	
		// DebugOscMessage("ProcessOscMessage ",m);
	    const char *types = m.TypeTags();
		const char *addr = m.AddressPattern();
		int millinow = Pt_Time();
		Nprocessed++;
		NosuchDebug(1,"ProcessOscMessage source=%s millinow=%d addr=%s",
			source==NULL?"NULL?":source,millinow,addr);

		if (checkAddrPattern(addr,"/tuio/25Dblb")) {

			std::string cmd = ArgAsString(m,0);
			int na = (int)strlen(types);
			// NosuchDebug("/tuio/25Dblb cmd=%s\n",cmd.c_str());
			if (cmd == "alive") {
				// if ( na > 1 )
				NosuchDebug(2,"25Dblb alive types=%s na=%d\n",types,na);
				for (int i = 1; i < na; i++) {
					int sidnum = ArgAsInt32(m,i);
					std::string sid = sidString(sidnum,source);

					Region* rgn = _palette->RegionForSid(sid);
					if ( rgn == NULL ) {
						NosuchDebug("Unable to find region for sid=%s",sid.c_str());
					} else {
						rgn->touchCursor(sid, millinow);
					}
				}
				thispalette->checkCursorUp(millinow);
			} else if (cmd == "fseq") {
				// int seq = ArgAsInt32(m,1);
			} else if (cmd == "set") {
				// NosuchDebug("25Dblb set na=%d\n",na);
				int sidnum = ArgAsInt32(m,1);
				std::string sid = sidString(sidnum,source);
				NosuchDebug(1,"set sid = %s",sid.c_str());
				// int rid = thispalette->regionOfSid(sid);
				// Region* r = thispalette->getRegion(rid);
				Region* r = thispalette->RegionForSid(sid);
				if ( !r ) {
					NosuchDebug("Unable to find region for sid=%s",sid.c_str());
					return;
				}
				float x = ArgAsFloat(m,2);
				float y = ArgAsFloat(m,3);
				float depth = ArgAsFloat(m,4);
				float tuio_a = ArgAsFloat(m,5);   // Angle
				float tuio_w = ArgAsFloat(m,6);
				float tuio_h = ArgAsFloat(m,7);
				float tuio_f = ArgAsFloat(m,8);   // Area
				// y = 1.0f - y;
				xy_adjust(1.3f, x, y);
				r->setCursor(sid, millinow, NosuchVector(x,y), depth, tuio_f);
			}
			return;

		} else if (checkAddrPattern(addr,"/tuio/2Dcur")) {

			std::string cmd = ArgAsString(m,0);
			int na = (int)strlen(types);
			if (cmd == "alive") {
				for (int i = 1; i < na; i++) {
					int sidnum = ArgAsInt32(m,i);
					std::string sid = sidString(sidnum,source);
					Region* r = thispalette->RegionForSid(sid);
					if ( !r ) {
						NosuchDebug("Unable to find region for sid=%s",sid.c_str());
						return;
					}
					r->touchCursor(sid, millinow);
				}
				thispalette->checkCursorUp(millinow);
			} else if (cmd == "fseq") {
				// int seq = ArgAsInt32(m,1);
			} else if (cmd == "set") {
				// It looks like "/tuio/2Dcur set s x y X Y m"
				int sidnum = ArgAsInt32(m,1);
				std::string sid = sidString(sidnum,source);
				Region* r = thispalette->RegionForSid(sid);
				if ( !r ) {
					NosuchDebug("Unable to find region for sid=%s",sid.c_str());
					return;
				}
				float x = ArgAsFloat(m,2);
				float y = ArgAsFloat(m,3);
				float depth = r->depth2dValue();
				float tuio_f = r->area2dValue();

				y = 1.0f - y;

				NosuchDebug(1,"/tuio/2Dcur processed=%d millinow=%d xy=%.3f,%.3f",Nprocessed,millinow,x,y);

				xy_adjust(1.3f, x, y);  // Should I do this for non-SpacePalette TUIO?  Maybe less, like 1.1?

				r->setCursor(sid, millinow, NosuchVector(x,y), depth, tuio_f);
			}
			return;
		}
		// NosuchDebug("Time=%ld GOT OSC addr=%s\n",timeGetTime(),addr);
		if ( strncmp(addr,"/tuio/",6) == 0 ) {
		}
		// First do things that have no arguments
		if ( strcmp(addr,"/clear") == 0 ) {
		} else if ( strcmp(addr,"/list") == 0 ) {
		} else if ( strcmp(addr,"/run") == 0 ) {
		} else if ( strcmp(addr,"/stop") == 0 ) {
		}

		NosuchDebug("PaletteOscInput - NO HANDLER FOR addr=%s",m.AddressPattern());
	} catch( osc::Exception& e ){
		// any parsing errors such as unexpected argument types, or 
		// missing arguments get thrown as exceptions.
		NosuchDebug("ProcessOscMessage error while parsing message: %s : %s",m.AddressPattern(),e.what());
	} catch (NosuchException& e) {
		NosuchDebug("ProcessOscMessage, NosuchException: %s",e.message());
	} catch (...) {
		// This doesn't seem to work - it doesn't seem to catch other exceptions...
		NosuchDebug("ProcessOscMessage, some other kind of exception occured during !?");
	}
}

#if 0
void PaletteServer::RespondToHttp(NosuchConnection *c, char*& memblock, size_t& memsize) {

	int doingpost = false;
	int doingget = false;
	int readingdata = false;
	std::string alldata;
	std::string get_fn;
	std::string ctype = "text/html";

	std::string urlstr(c->url());
	if ( urlstr == "" || urlstr == "/" ) {
		urlstr = "/index.html";
	}
	int request_type = c->request_type();

	NosuchDebug(2,"PaletteFF::RespondToHttp GOT request_type=%d\n",request_type);

	if ( request_type == REQUEST_GET ) {
		size_t dot = urlstr.rfind('.');
		if ( dot > 0 ) {
			std::string suff = urlstr.substr(dot);
			if ( suff == ".html" || suff == ".htm" ) {
				ctype = "text/html";
			} else if ( suff == ".css" ) {
				ctype = "text/css";
			} else if ( suff == ".jpg" || suff == ".jpeg" ) {
				ctype = "image/jpeg";
			} else if ( suff == ".ppm" ) {
				ctype = "image/x-portable-pixmap";
			} else if ( suff == ".json" ) {
				ctype = "application/json";
			} else if ( suff == ".js" ) {
				ctype = "text/javascript";
			}
		}
		// c->_content_type = ctype;
		std::string fn = m_htmldir + urlstr;

		NosuchDebug(1,"PaletteServer GET %s\n",urlstr.c_str());
		NosuchDebug(2,"   reading %s\n",fn.c_str());

		// Note that it opens it at the end, which we use to get the size
		std::ifstream f(fn.c_str(), std::ifstream::in | std::ifstream::binary | std::ifstream::ate);
		if ( ! f.is_open() ) {
			httperror("Unable to open: "+fn+"\n",memblock,memsize);
			return;
		}

		std::string header = httpheader(ctype);

		int filesize = (int)(f.tellg());   // see note above
		size_t headersize = header.size();
		memsize = headersize+filesize;
		memblock = new char[memsize];
		NosuchDebug(1,"NEW memblock in respondtohttp, memsize=%d",memsize);
		memcpy(memblock,header.c_str(),headersize);
		f.seekg(0,std::ifstream::beg);
		f.read(memblock+headersize,(std::streamsize)memsize);
		f.close();
		return;
	}

	if ( request_type == REQUEST_POST ) {
		// data is the input to the POST
		std::string dd = c->data();   // Hmm, when I combine this with the next statement, it doesn't work?  Odd.
		const char *pp = dd.c_str();
		const char *endpp = strchr(pp,'\0');
		bool hasnewline = ( endpp && endpp > pp && *(endpp-1) == '\n' );
		NosuchDebug(2,"POST request: %s%s",pp,hasnewline?"":"\n");
		if ( *pp != '{' ) {
			NosuchDebug("HEY!!! No curly!?");
		}
		cJSON *request = cJSON_Parse(c->data().c_str());
		if ( request ) {
			std::string ret;
			std::string i;
			cJSON *c_jsonrpc = cJSON_GetObjectItem(request,"jsonrpc");
			if ( ! c_jsonrpc ) {
				ret = error_json(-32700,"No jsonrpc value in JSON!?");
				goto getout;
			}
			cJSON *c_method = cJSON_GetObjectItem(request,"method");
			if ( ! c_method ) {
				ret = error_json(-32700,"No method value in JSON!?");
				goto getout;
			}
			cJSON *c_params = cJSON_GetObjectItem(request,"params");
			// It's okay if c_params is NULL
			cJSON *c_id = cJSON_GetObjectItem(request,"id");
			if ( ! c_id ) {
				ret = error_json(-32700,"No id value in JSON!?");
				goto getout;
			}
			char *method = c_method->valuestring;
			if ( c_id->type == cJSON_Number ) {
				i = NosuchSnprintf("%d",c_id->valueint);
			} else if ( c_id->type == cJSON_String ) {
				i = NosuchSnprintf("%s",c_id->valuestring);
			} else {
				ret = error_json(-32700,"Bad id value in JSON!?");
				goto getout;
			}
			const char *id = i.c_str();
			NosuchDebug(2,"got JSON method=%s\n",method);

			// ret = ProcessJsonMessage(c,method,c_params,id);
			int nproc = _processors.size();
			// NosuchDebug("JSON nproc=%d method=%s\n",nproc,method);
			if ( _processors.size() == 0 ) {
				std::string s = "No Json Processors!  JSON message ignored";
				ret = error_json(-32000,s.c_str(),id);
				goto getout;
			}
			NosuchJsonMessageProcessor* mp = _processors.front();
			ret = mp->ProcessJsonMessage(c,method,c_params,id);

			cJSON_Delete(request);

		getout:
			NosuchDebug(2,"POST response: %s\n",ret.c_str());
			makeresult("application/json",ret,memblock,memsize);
		} else {
			httperror("Did not find jsonrpc input in POST!\n",memblock,memsize);
		}
	} else {
		httperror("Did not find GET or POST in header?\n",memblock,memsize);
	}
}
#endif

std::string PaletteFF::RespondToJson(std::string method, cJSON *params, const char *id) {

	// We want JSON requests to be interpreted in the main thread of the FFGL plugin,
	// so we stuff the request into json_* variables and wait for the main thread to
	// pick it up (in ProcessOpenGL)
	NosuchLock(&json_mutex,"json");

	json_pending = true;
	json_method = std::string(method);
	json_params = params;
	json_id = id;

	bool err = false;
	while ( json_pending ) {
		NosuchDebug(2,"####### Waiting for json_cond! millinow=%d",Palette::now);
		int e = pthread_cond_wait(&json_cond, &json_mutex);
		if ( e ) {
			NosuchDebug(2,"####### ERROR from pthread_cond_wait e=%d now=%d",e,Palette::now);
			err = true;
			break;
		}
	}
	std::string result;
	if ( err ) {
		result = error_json(-32000,"Error waiting for json!?");
	} else {
		result = json_result;
	}

	NosuchUnlock(&json_mutex,"json");

	return result;
}


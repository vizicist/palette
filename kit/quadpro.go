package kit

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"sort"
	"strings"
	"sync"
	"time"
)

var TheQuadPro *QuadPro

type QuadPro struct {

	// Per-patch things
	patch      map[string]*Patch
	patchLogic map[string]*PatchLogic

	started   bool
	rand      *rand.Rand
	randMutex sync.Mutex
}

func NewQuadPro() *QuadPro {
	quadpro := &QuadPro{
		patch:      map[string]*Patch{},
		patchLogic: map[string]*PatchLogic{},
		rand:       rand.New(rand.NewSource(1)),
	}
	return quadpro
}

func (quadpro *QuadPro) Stop() {
	quadpro.started = false
}

func (quadpro *QuadPro) Api(api string, apiargs map[string]string) (result string, err error) {

	switch api {

	case "get":
		return quadpro.onGet(apiargs)

	case "event":
		return "", fmt.Errorf("event no longer handled in Quadpro.Api")

	case "ANO":
		for _, patch := range quadpro.patch {
			patch.Synth().SendANO()
		}
		return "", nil

	case "echo":
		value, ok := apiargs["value"]
		if !ok {
			value = "ECHO!"
		}
		return value, nil

	case "load":
		category, oksaved := apiargs["category"]
		if !oksaved {
			return "", fmt.Errorf("missing category parameter")
		}
		filename, oksaved := apiargs["filename"]
		if !oksaved {
			return "", fmt.Errorf("missing filename parameter")
		}
		// Loading a preset no longer turns off attract mode
		// TheAttractManager.SetAttractMode(false)
		return "", quadpro.Load(category, filename)

	case "loadrand":
		category, oksaved := apiargs["category"]
		if !oksaved {
			return "", fmt.Errorf("missing category parameter")
		}
		return quadpro.loadQuadRand(category)

	case "save":
		category, oksaved := apiargs["category"]
		if !oksaved {
			return "", fmt.Errorf("missing category parameter")
		}
		filename, oksaved := apiargs["filename"]
		if !oksaved {
			return "", fmt.Errorf("missing filename parameter")
		}
		return "", quadpro.save(category, filename)

	case "test":
		ntimes := ArgToInt("ntimes", apiargs)
		intervalf, err := GetParamFloat("global.testgestureinterval")
		if err != nil {
			LogIfError(err)
			return "", err
		}
		testtype, oktype := apiargs["testtype"]
		if !oktype {
			testtype = ""
		}
		interval := time.Duration(intervalf * 1000000000)
		LogInfo("QuadPro.ExecuteApi test start", "ntimes", ntimes, "interval", interval)
		quadpro.doTest(testtype, ntimes, interval)
		LogInfo("QuadPro.ExecuteApi test end", "ntimes", ntimes, "interval", interval)
		return "", nil

	default:
		LogWarn("QuadPro.ExecuteApi api is not recognized\n", "api", api)
		return "", fmt.Errorf("QuadPro.Api unrecognized api=%s", api)
	}
}

var CursorSourceToQuadPreset ParamsMap

func (quadpro *QuadPro) Start() {

	if quadpro.started {
		LogInfo("QuadPro.Start: already started")
		return
	}
	quadpro.started = true

	buttonPath := ConfigFilePath("buttons.json")
	if fileExists(buttonPath) {
		bytes, err := os.ReadFile(buttonPath)
		if err != nil {
			LogError(fmt.Errorf("unable to read buttons.json"), "err", err)
		} else {
			var f any
			err = json.Unmarshal(bytes, &f)
			if err != nil {
				LogError(fmt.Errorf("unable to Unmarshal"), "buttonPath", buttonPath)
			} else {
				buttonMap, ok := f.(map[string]any)
				if !ok {
					LogIfError(err)
				} else {
					CursorSourceToQuadPreset = buttonMap
				}
			}
		}
	}

	TheCursorManager.AddCursorHandler("QuadPro", TheQuadPro, "A", "B", "C", "D")

	_ = quadpro.addPatch("A")
	_ = quadpro.addPatch("B")
	_ = quadpro.addPatch("C")
	_ = quadpro.addPatch("D")

	err := quadpro.Load("quad", "_Current")
	LogIfError(err)
}

func (quadpro *QuadPro) Status(source string) string {
	return "status" + source
}

func (quadpro *QuadPro) PatchForCursorEvent(ce CursorEvent) (patch *Patch, button string) {
	source := ce.Source()
	// If the source has some patchLogic...
	patchLogic, ok := quadpro.patchLogic[source]
	if !ok {
		patch = nil
	} else {
		patch = patchLogic.patch
	}
	// If the source is a Button...
	_, ok = CursorSourceToQuadPreset[source]
	if ok {
		button = source
	}
	return patch, button
}

func (quadpro *QuadPro) onCursorEvent(state ActiveCursor) error {

	// Any non-attract-generated cursor or Button will turn attract mode off.
	if !state.Current.IsAttractGenerated() && TheAttractManager.AttractModeIsOn() {
		TheAttractManager.SetAttractMode(false)
	}
	if !state.Current.IsAttractGenerated() {
		// If it's not generated by the attract mode,
		// reset the attract timer for detecting idle time
		TheAttractManager.attractMutex.Lock()
		TheAttractManager.lastAttractModeChange = time.Now() // reset the timer
		TheAttractManager.attractMutex.Unlock()
	}

	if state.Button != "" {

		mmtt_buttondepth := float32(0.1)
		// To avoid false triggering, we only want to be triggered when the
		// Z depth is small, i.e. when something has just entered the button area.
		if state.Current.Ddu == "down" && state.Current.Pos.Z < mmtt_buttondepth {
			val, ok := CursorSourceToQuadPreset[state.Button]
			if !ok {
				LogInfo("No Preset is attached to button", "button", state.Button)
			} else {
				preset := val.(string)
				if TheQuadPro != nil {
					LogOfType("cursor", "Button down", "z", state.Current.Pos.Z)
					err := TheQuadPro.Load("quad", preset)
					if err != nil {
						return err
					}
					TheResolume().showText(preset)
				}
			}
		}
		// Buttons only do things on cursor down
		return nil
	}

	// For the moment, the cursor to patchLogic mapping is 1-to-1.
	// I.e. ce.Source of "A" maps to patchLogic "A"
	source := state.Current.Source()
	patchLogic, ok := quadpro.patchLogic[source]
	if !ok || patchLogic == nil {
		LogWarn("Source doesn't exist in patchLogic", "source", source)
		return nil
	}
	cursorStyle := patchLogic.patch.Get("misc.cursorstyle")
	gensound := IsTrueValue(patchLogic.patch.Get("misc.generatesound"))
	genvisual := IsTrueValue(patchLogic.patch.Get("misc.generatevisual"))
	attractSound := IsTrueValue(GetParamWithDefault("global.attractsound", "false"))
	// in attract mode, don't generate sound from attractMode cursors
	attractIsOn := TheAttractManager.AttractModeIsOn()
	isAttractGenerated := state.Current.IsAttractGenerated()
	makeSound := false
	if !attractIsOn && !isAttractGenerated {
		makeSound = true
	}
	if attractIsOn && (attractSound || !isAttractGenerated) {
		makeSound = true
	}

	if gensound && makeSound {
		patchLogic.generateSoundFromCursor(state.Current, cursorStyle)
	}
	if genvisual {
		patchLogic.generateVisualsFromCursor(state.Current)
	}
	return nil
}

func (quadpro *QuadPro) onClientRestart(portnum int) {
	LogOfType("resolume", "quadpro got clientrestart", "portnum", portnum)
	// Refresh the patch that has that portnum
	for _, patch := range quadpro.patch {
		patch.RefreshAllIfPortnumMatches(portnum)
	}
}

func (quadpro *QuadPro) onGet(apiargs map[string]string) (result string, err error) {
	paramName, ok := apiargs["name"]
	if !ok {
		return "", fmt.Errorf("QuadPro.onPatchGet: Missing name argument")
	}
	if strings.HasPrefix(paramName, "global") {
		return GetParam(paramName)
	} else {
		return "", fmt.Errorf("QuadPro.onGet: can't handle parameter %s", paramName)
	}
}

func (quadpro *QuadPro) onMidiEvent(me MidiEvent) error {
	LogOfType("midi", "QuadPro.onMidiEvent", "me", me)
	return nil
}

func (quadpro *QuadPro) RandomPatchName() string {
	quadpro.randMutex.Lock()
	defer quadpro.randMutex.Unlock()
	return string("ABCD"[quadpro.rand.Intn(len(Patchs))])
}

func (quadpro *QuadPro) doTest(testtype string, ntimes int, interval time.Duration) {

	numsteps, err := GetParamInt("global.testgesturenumsteps")
	if err != nil {
		LogIfError(err)
		return
	}
	durfloat, err := GetParamFloat("global.testgestureduration")
	if err != nil {
		LogIfError(err)
		return
	}
	dur := time.Duration(durfloat * float64(time.Second))

	for n := 0; n < ntimes; n++ {

		switch testtype {
		case "":
			randomPatchName := quadpro.RandomPatchName()
			tag := randomPatchName + ",test"
			go TheCursorManager.GenerateRandomGesture(tag, numsteps, dur)

		case "center":
			tag := "A,testcenter"
			half := interval / 2
			go TheCursorManager.GenerateCenterGesture(tag, half)
		}

		time.Sleep(interval)
	}
}

func (quadpro *QuadPro) loadQuadRand(category string) (string, error) {

	arr, err := SavedFileList(category)
	if err != nil {
		return "", err
	}

	quadpro.randMutex.Lock()
	rn := quadpro.rand.Uint64() % uint64(len(arr))
	quadpro.randMutex.Unlock()

	err = quadpro.Load(category, arr[rn])
	if err != nil {
		LogIfError(err)
		return "", err
	}

	for _, patch := range quadpro.patch {
		patch.RefreshAllPatchValues()
	}
	return arr[rn], err
}

func (quadpro *QuadPro) Load(category string, filename string) error {

	paramsMap, err := LoadParamsMapOfCategory(category, filename)
	if err != nil {
		LogIfError(err)
		return err
	}

	LogInfo("QuadPro.Load", "category", category, "filename", filename)
	isOn := TheAttractManager.attractModeIsOn.Load()
	PublishFromEngine("quadro.load", fmt.Sprintf("category=%s filename=%s attractmode=%v", category, filename, isOn))

	var lasterr error

	if category == "global" {
		err := fmt.Errorf("HACK! quadpro.Load shouldn't load global parameters")
		LogError(err)
		lasterr = err
	} else {
		for _, patch := range quadpro.patch {
			err := patch.Load(category, paramsMap)
			if err != nil {
				LogIfError(err)
				lasterr = err
			}
		}
	}

	// Decide what _Current things we should save
	// when we load something.  E.g. if we're
	// loading a patch with something, we want to
	// then save the entire quad
	err = nil
	switch category {
	case "global":
		// No need to save _Current if we're loading it.
		if filename != "_Current" {
			err = SaveGlobalParams()
		}
	case "quad":
		if filename != "_Current" {
			err = quadpro.saveQuad("_Current")
		}
	case "patch", "sound", "visual", "effect", "misc":
		// If we're loading a patch (or something inside a patch, like sound, visual, etc),
		// we save the entire quad, since that's our real persistent state
		if filename != "_Current" {
			err = quadpro.saveQuad("_Current")
		}
	}
	if err != nil {
		LogIfError(err)
		lasterr = err
	}
	return lasterr
}

func (quadpro *QuadPro) save(category string, filename string) (err error) {

	LogOfType("saved", "QuadPro.save", "category", category, "filename", filename)

	if category == "global" {
		LogWarn("QuadPro.save: shouldn't be saving global?")
		err = fmt.Errorf("QuadPro.save: global shouldn't be handled here")
	} else if category == "quad" {
		err = quadpro.saveQuad(filename)
	} else {
		err = fmt.Errorf("QuadPro.Api: unhandled save category %s", category)
	}
	if err != nil {
		LogIfError(err)
	}
	return err
}

func (quadpro *QuadPro) saveQuad(quadName string) error {

	category := "quad"
	path, err := WritableSavedFilePath(category, quadName, ".json")
	if err != nil {
		LogIfError(err)
		return err
	}

	LogOfType("saved", "QuadPro.saveQuad", "quad", quadName)

	sortedPatchNames := []string{}
	for _, patch := range quadpro.patch {
		sortedPatchNames = append(sortedPatchNames, patch.Name())
	}
	sort.Strings(sortedPatchNames)

	s := "{\n    \"params\": {\n"
	sep := ""
	for _, patchName := range sortedPatchNames {
		patch := quadpro.patch[patchName]
		sortedNames := patch.ParamNames()
		for _, fullName := range sortedNames {
			valstring := patch.Get(fullName)
			s += fmt.Sprintf("%s        \"%s-%s\":\"%s\"", sep, patch.Name(), fullName, valstring)
			sep = ",\n"
		}
	}
	s += "\n    }\n}"
	data := []byte(s)
	return os.WriteFile(path, data, 0644)
}

func (quadpro *QuadPro) addPatch(name string) *Patch {
	patch := NewPatch(name)
	quadpro.patch[name] = patch
	quadpro.patchLogic[name] = NewPatchLogic(patch)
	return patch
}

/*
func (quadpro *QuadPro) scheduleNoteNow(dest string, pitch, velocity uint8, duration Clicks) {
	LogInfo("QuadPro.scheculeNoteNow", "dest", dest, "pitch", pitch)
	pe := &PhraseElement{Value: NewNoteFull(0, pitch, velocity, duration)}
	phr := NewPhrase().InsertElement(pe)
	phr.Destination = dest
	SchedulePhrase(phr, CurrentClick(), dest)
}
*/

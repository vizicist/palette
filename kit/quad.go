package kit

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"sort"
	"strings"
	"sync"
	"time"
)

var TheQuad *Quad

type Quad struct {

	// Per-patch things
	patch      map[string]*Patch
	patchLogic map[string]*PatchLogic

	started   bool
	rand      *rand.Rand
	randMutex sync.Mutex
}

func NewQuad() *Quad {
	quad := &Quad{
		patch:      map[string]*Patch{},
		patchLogic: map[string]*PatchLogic{},
		rand:       rand.New(rand.NewSource(1)),
	}
	return quad
}

func (quad *Quad) Stop() {
	quad.started = false
}

func (quad *Quad) Api(api string, apiargs map[string]string) (result string, err error) {

	switch api {

	case "get":
		return quad.onGet(apiargs)

	case "event":
		return "", fmt.Errorf("event no longer handled in Quadpro.Api")

	case "ANO":
		for _, patch := range quad.patch {
			patch.Synth().SendANO()
		}
		return "", nil

	case "echo":
		value, ok := apiargs["value"]
		if !ok {
			value = "ECHO!"
		}
		return value, nil

	case "load":
		category, oksaved := apiargs["category"]
		if !oksaved {
			return "", fmt.Errorf("missing category parameter")
		}
		filename, oksaved := apiargs["filename"]
		if !oksaved {
			return "", fmt.Errorf("missing filename parameter")
		}
		// Loading a preset no longer turns off attract mode
		// TheAttractManager.SetAttractMode(false)
		return "", quad.Load(category, filename)

	case "loadrand":
		category, oksaved := apiargs["category"]
		if !oksaved {
			return "", fmt.Errorf("missing category parameter")
		}
		return quad.loadQuadRand(category)

	case "save":
		category, oksaved := apiargs["category"]
		if !oksaved {
			return "", fmt.Errorf("missing category parameter")
		}
		filename, oksaved := apiargs["filename"]
		if !oksaved {
			return "", fmt.Errorf("missing filename parameter")
		}
		return "", quad.save(category, filename)

	case "test":
		ntimes := ArgToInt("ntimes", apiargs)
		intervalf, err := GetParamFloat("global.testgestureinterval")
		if err != nil {
			LogIfError(err)
			return "", err
		}
		testtype, oktype := apiargs["testtype"]
		if !oktype {
			testtype = ""
		}
		interval := time.Duration(intervalf * 1000000000)
		LogInfo("Quad.ExecuteApi test start", "ntimes", ntimes, "interval", interval)
		quad.doTest(testtype, ntimes, interval)
		LogInfo("Quad.ExecuteApi test end", "ntimes", ntimes, "interval", interval)
		return "", nil

	default:
		LogWarn("Quad.ExecuteApi api is not recognized\n", "api", api)
		return "", fmt.Errorf("Quad.Api unrecognized api=%s", api)
	}
}

var CursorSourceToQuadPreset ParamsMap

func (quad *Quad) Start() {

	if quad.started {
		LogInfo("Quad.Start: already started")
		return
	}
	quad.started = true

	buttonPath := ConfigFilePath("buttons.json")
	if fileExists(buttonPath) {
		bytes, err := os.ReadFile(buttonPath)
		if err != nil {
			LogError(fmt.Errorf("unable to read buttons.json"), "err", err)
		} else {
			var f any
			err = json.Unmarshal(bytes, &f)
			if err != nil {
				LogError(fmt.Errorf("unable to Unmarshal"), "buttonPath", buttonPath)
			} else {
				buttonMap, ok := f.(map[string]any)
				if !ok {
					LogIfError(err)
				} else {
					CursorSourceToQuadPreset = buttonMap
				}
			}
		}
	}

	TheCursorManager.AddCursorHandler("Quad", TheQuad, "A", "B", "C", "D")

	_ = quad.addPatch("A")
	_ = quad.addPatch("B")
	_ = quad.addPatch("C")
	_ = quad.addPatch("D")

	err := quad.Load("quad", "_Current")
	LogIfError(err)
}

func (quad *Quad) Status(source string) string {
	return "status" + source
}

func (quad *Quad) PatchForCursorEvent(ce CursorEvent) (patch *Patch, button string) {
	source := ce.Source()
	// If the source has some patchLogic...
	patchLogic, ok := quad.patchLogic[source]
	if !ok {
		patch = nil
	} else {
		patch = patchLogic.patch
	}
	// If the source is a Button...
	_, ok = CursorSourceToQuadPreset[source]
	if ok {
		button = source
	}
	return patch, button
}

func (quad *Quad) onCursorEvent(state ActiveCursor) error {

	// Any non-attract-generated cursor or Button will turn attract mode off.
	if !state.Current.IsAttractGenerated() && TheAttractManager.AttractModeIsOn() {
		TheAttractManager.SetAttractMode(false)
	}
	if !state.Current.IsAttractGenerated() {
		// If it's not generated by the attract mode,
		// reset the attract timer for detecting idle time
		TheAttractManager.attractMutex.Lock()
		TheAttractManager.lastAttractModeChange = time.Now() // reset the timer
		TheAttractManager.attractMutex.Unlock()
	}

	if state.Button != "" {

		mmtt_buttondepth := float32(0.1)
		// To avoid false triggering, we only want to be triggered when the
		// Z depth is small, i.e. when something has just entered the button area.
		if state.Current.Ddu == "down" && state.Current.Pos.Z < mmtt_buttondepth {
			val, ok := CursorSourceToQuadPreset[state.Button]
			if !ok {
				LogInfo("No Preset is attached to button", "button", state.Button)
			} else {
				preset := val.(string)
				if TheQuad != nil {
					LogOfType("cursor", "Button down", "z", state.Current.Pos.Z)
					err := TheQuad.Load("quad", preset)
					if err != nil {
						return err
					}
					TheResolume().showText(preset)
				}
			}
		}
		// Buttons only do things on cursor down
		return nil
	}

	// For the moment, the cursor to patchLogic mapping is 1-to-1.
	// I.e. ce.Source of "A" maps to patchLogic "A"
	source := state.Current.Source()
	patchLogic, ok := quad.patchLogic[source]
	if !ok || patchLogic == nil {
		LogWarn("Source doesn't exist in patchLogic", "source", source)
		return nil
	}
	cursorStyle := patchLogic.patch.Get("misc.cursorstyle")
	gensound := IsTrueValue(patchLogic.patch.Get("misc.generatesound"))
	genvisual := IsTrueValue(patchLogic.patch.Get("misc.generatevisual"))
	attractSound := IsTrueValue(GetParamWithDefault("global.attractsound", "false"))
	// in attract mode, don't generate sound from attractMode cursors
	attractIsOn := TheAttractManager.AttractModeIsOn()
	isAttractGenerated := state.Current.IsAttractGenerated()
	makeSound := false
	if !attractIsOn && !isAttractGenerated {
		makeSound = true
	}
	if attractIsOn && (attractSound || !isAttractGenerated) {
		makeSound = true
	}

	if gensound && makeSound {
		patchLogic.generateSoundFromCursor(state.Current, cursorStyle)
	}
	if genvisual {
		patchLogic.generateVisualsFromCursor(state.Current)
	}
	return nil
}

func (quad *Quad) onClientRestart(portnum int) {
	LogOfType("resolume", "quad got clientrestart", "portnum", portnum)
	// Refresh the patch that has that portnum
	for _, patch := range quad.patch {
		patch.RefreshAllIfPortnumMatches(portnum)
	}
}

func (quad *Quad) onGet(apiargs map[string]string) (result string, err error) {
	paramName, ok := apiargs["name"]
	if !ok {
		return "", fmt.Errorf("Quad.onPatchGet: Missing name argument")
	}
	if strings.HasPrefix(paramName, "global") {
		return GetParam(paramName)
	} else {
		return "", fmt.Errorf("Quad.onGet: can't handle parameter %s", paramName)
	}
}

func (quad *Quad) onMidiEvent(me MidiEvent) error {
	LogOfType("midi", "Quad.onMidiEvent", "me", me)
	return nil
}

func (quad *Quad) RandomPatchName() string {
	quad.randMutex.Lock()
	defer quad.randMutex.Unlock()
	return string("ABCD"[quad.rand.Intn(len(Patchs))])
}

func (quad *Quad) doTest(testtype string, ntimes int, interval time.Duration) {

	numsteps, err := GetParamInt("global.testgesturenumsteps")
	if err != nil {
		LogIfError(err)
		return
	}
	durfloat, err := GetParamFloat("global.testgestureduration")
	if err != nil {
		LogIfError(err)
		return
	}
	dur := time.Duration(durfloat * float64(time.Second))

	for n := 0; n < ntimes; n++ {

		switch testtype {
		case "":
			randomPatchName := quad.RandomPatchName()
			tag := randomPatchName + ",test"
			go TheCursorManager.GenerateRandomGesture(tag, numsteps, dur)

		case "center":
			tag := "A,testcenter"
			half := interval / 2
			go TheCursorManager.GenerateCenterGesture(tag, half)
		}

		time.Sleep(interval)
	}
}

func (quad *Quad) loadQuadRand(category string) (string, error) {

	arr, err := SavedFileList(category)
	if err != nil {
		return "", err
	}

	quad.randMutex.Lock()
	rn := quad.rand.Uint64() % uint64(len(arr))
	quad.randMutex.Unlock()

	err = quad.Load(category, arr[rn])
	if err != nil {
		LogIfError(err)
		return "", err
	}

	for _, patch := range quad.patch {
		patch.RefreshAllPatchValues()
	}
	return arr[rn], err
}

func (quad *Quad) Load(category string, filename string) error {

	paramsMap, err := LoadParamsMapOfCategory(category, filename)
	if err != nil {
		LogIfError(err)
		return err
	}

	LogInfo("Quad.Load", "category", category, "filename", filename)
	isOn := TheAttractManager.attractModeIsOn.Load()
	PublishFromEngine("quadro.load", fmt.Sprintf("category=%s filename=%s attractmode=%v", category, filename, isOn))

	var lasterr error

	if category == "global" {
		err := fmt.Errorf("HACK! quad.Load shouldn't load global parameters")
		LogError(err)
		lasterr = err
	} else {
		for _, patch := range quad.patch {
			err := patch.Load(category, paramsMap)
			if err != nil {
				LogIfError(err)
				lasterr = err
			}
		}
	}

	// Decide what _Current things we should save
	// when we load something.  E.g. if we're
	// loading a patch with something, we want to
	// then save the entire quad
	err = nil
	switch category {
	case "global":
		// No need to save _Current if we're loading it.
		if filename != "_Current" {
			err = SaveGlobalParams()
		}
	case "quad":
		if filename != "_Current" {
			err = quad.saveQuad("_Current")
		}
	case "patch", "sound", "visual", "effect", "misc":
		// If we're loading a patch (or something inside a patch, like sound, visual, etc),
		// we save the entire quad, since that's our real persistent state
		if filename != "_Current" {
			err = quad.saveQuad("_Current")
		}
	}
	if err != nil {
		LogIfError(err)
		lasterr = err
	}
	return lasterr
}

func (quad *Quad) save(category string, filename string) (err error) {

	LogOfType("saved", "Quad.save", "category", category, "filename", filename)

	if category == "global" {
		LogWarn("quad.save: shouldn't be saving global?")
		err = fmt.Errorf("quad.save: global shouldn't be handled here")
	} else if category == "quad" {
		err = quad.saveQuad(filename)
	} else {
		err = fmt.Errorf("quad.save: unhandled save category %s", category)
	}
	if err != nil {
		LogIfError(err)
	}
	return err
}

func (quad *Quad) saveQuad(quadName string) error {

	category := "quad"
	path, err := WritableSavedFilePath(category, quadName, ".json")
	if err != nil {
		LogIfError(err)
		return err
	}

	LogOfType("saved", "Quad.saveQuad", "quad", quadName)

	sortedPatchNames := []string{}
	for _, patch := range quad.patch {
		sortedPatchNames = append(sortedPatchNames, patch.Name())
	}
	sort.Strings(sortedPatchNames)

	s := "{\n    \"params\": {\n"
	sep := ""
	for _, patchName := range sortedPatchNames {
		patch := quad.patch[patchName]
		sortedNames := patch.ParamNames()
		for _, fullName := range sortedNames {
			valstring := patch.Get(fullName)
			s += fmt.Sprintf("%s        \"%s-%s\":\"%s\"", sep, patch.Name(), fullName, valstring)
			sep = ",\n"
		}
	}
	s += "\n    }\n}"
	data := []byte(s)
	return os.WriteFile(path, data, 0644)
}

func (quad *Quad) addPatch(name string) *Patch {
	patch := NewPatch(name)
	quad.patch[name] = patch
	quad.patchLogic[name] = NewPatchLogic(patch)
	return patch
}

/*
func (quad *Quad) scheduleNoteNow(dest string, pitch, velocity uint8, duration Clicks) {
	LogInfo("Quad.scheculeNoteNow", "dest", dest, "pitch", pitch)
	pe := &PhraseElement{Value: NewNoteFull(0, pitch, velocity, duration)}
	phr := NewPhrase().InsertElement(pe)
	phr.Destination = dest
	SchedulePhrase(phr, CurrentClick(), dest)
}
*/
